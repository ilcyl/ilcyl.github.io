<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软件项目管理</title>
    <link href="/ilcyl/ilcyl.github.io.git/2024/12/23/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <url>/ilcyl/ilcyl.github.io.git/2024/12/23/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="软件项目管理"><a class="markdownIt-Anchor" href="#软件项目管理">#</a> 软件项目管理</h1><h1 id="一-项目管理概述-4"><a class="markdownIt-Anchor" href="#一-项目管理概述-4">#</a> 一、项目管理概述 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 4</h1><h2 id="11-相关定义"><a class="markdownIt-Anchor" href="#11-相关定义">#</a> 1.1 相关定义</h2><h3 id="111-项目定义"><a class="markdownIt-Anchor" href="#111-项目定义">#</a> 1.1.1 项目定义</h3><p>项目是为了创造一个唯一的产品或提供一个唯一的服务而进行的临时性的努力</p><h3 id="112-pmbok项目管理知识体系指南"><a class="markdownIt-Anchor" href="#112-pmbok项目管理知识体系指南">#</a> 1.1.2 PMBOK (项目管理知识体系指南)</h3><ul><li>初始、计划、控制、执行、结束</li></ul><h3 id="113-vuca时代"><a class="markdownIt-Anchor" href="#113-vuca时代">#</a> 1.1.3 VUCA 时代</h3><p>易变，不确定，复杂，模糊</p><h3 id="114-敏捷宣言"><a class="markdownIt-Anchor" href="#114-敏捷宣言">#</a> 1.1.4 敏捷宣言</h3><ul><li>个体和互动 高于 流程和工具</li><li>可工作的软件 高于 详尽的文档</li><li>客户合作 高于 合同谈判</li><li>响应变化 高于 遵循计划</li></ul><h3 id="115-主要ai赋能项"><a class="markdownIt-Anchor" href="#115-主要ai赋能项">#</a> 1.1.5 主要 AI 赋能项</h3><ul><li>降本增效</li><li>理解用户需求</li><li>项目决策能力提升</li><li>重塑组织结构</li><li>新的工作方式和文化</li></ul><h2 id="12-习题"><a class="markdownIt-Anchor" href="#12-习题">#</a> 1.2 习题</h2><ol><li>下面选项中不属于项目管理核心要素的是：风险</li><li>以下都是日常运作和项目的共同之处，除了：都是重复性工作</li><li>下面关于敏捷模型的描述不正确的是哪项：敏捷项目一次性提交项目交付成果</li></ol><h1 id="二-项目立项与招投标-4"><a class="markdownIt-Anchor" href="#二-项目立项与招投标-4">#</a> 二、项目立项与招投标 - - - - - - - - - - - - - - - - - - - - - - - - - 4</h1><h2 id="21-相关定义"><a class="markdownIt-Anchor" href="#21-相关定义">#</a> 2.1 相关定义</h2><h3 id="211-make-or-buy决策"><a class="markdownIt-Anchor" href="#211-make-or-buy决策">#</a> 2.1.1 Make or Buy 决策</h3><p><img src="../image/res2/1.png" alt=""></p><h3 id="212-项目招投标过程"><a class="markdownIt-Anchor" href="#212-项目招投标过程">#</a> 2.1.2 项目招投标过程</h3><p>甲方招标书定义：招标 → 乙方项目分析：投标 → 开标与评标 → 合同签署</p><h3 id="213-项目章程"><a class="markdownIt-Anchor" href="#213-项目章程">#</a> 2.1.3 项目章程</h3><p>授权书：确认项目存在的文件，包括对项目的确认、对项目经理的授权和项目目标的概述等。</p><h3 id="214-项目经理的职责"><a class="markdownIt-Anchor" href="#214-项目经理的职责">#</a> 2.1.4 项目经理的职责</h3><ul><li>开发计划，组织实施，项目控制</li><li>敏捷强调：仆人式领导方式</li></ul><h2 id="22-习题"><a class="markdownIt-Anchor" href="#22-习题">#</a> 2.2 习题</h2><ol><li>Make or Buy 决策：Make 代表 “自我开发”，Buy 代表 “委托开发”</li><li>项目招标对于一个项目的开发是必需的，即便项目是内部项目 ❌</li><li>项目立项需要获得项目经理的认可，但不需要项目发起人的认可 ❌</li><li>项目章程是项目执行组织高层批准的确认项目存在的文件，其中不包括对项目经理的授权 ❌</li><li>在软件项目合同中，甲方是需求方，乙方则是开发方 ✅</li></ol><h1 id="三-生存期模型-5"><a class="markdownIt-Anchor" href="#三-生存期模型-5">#</a> 三、生存期模型 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 5</h1><h2 id="31-相关定义"><a class="markdownIt-Anchor" href="#31-相关定义">#</a> 3.1 相关定义</h2><h3 id="311-项目生存期选择"><a class="markdownIt-Anchor" href="#311-项目生存期选择">#</a> 3.1.1 项目生存期选择</h3><ul><li>预测型：瀑布模型，V 模型 (需求、方案明确) 提前进行大量的计划工作，然后一次性执行；执行是一个连续的过程。</li><li>迭代型：(需求不明确，项目复杂性高、变更频繁) 允许对未完成的工作进行反馈，从而改进和修改该工作。</li><li>增量型：向客户提供各个已完成的，可能立即使用的可交付成果。</li><li>敏捷型：既有迭代，也有增量，便于完善工作，频繁交付。</li></ul><h3 id="312-敏捷模型需求不固定试探模式价值驱动"><a class="markdownIt-Anchor" href="#312-敏捷模型需求不固定试探模式价值驱动">#</a> 3.1.2 敏捷模型 (需求不固定，试探模式，价值驱动)</h3><ul><li>Scrum：目前使用率最高</li></ul><ol><li>3 个角色：产品负责人、开发团队、敏捷教练</li><li>3 个工件：Sprint 待办事项列表、产品待办清单、符合 “完成的定义” 的产品增量</li><li>5 个事件：Sprint 计划会、每日 Scrum 站会、Sprint 评审会、Sprint 回顾会、Sprint (短时间盒)</li><li>5 个价值观：开放、尊重、勇气、专注、承诺</li></ol><ul><li>XP：极限编程模型</li></ul><p>针对业务需求和软件开发实践的规则</p><ul><li>Kanban</li><li>DevOps：开发和运维工作紧密合作 (企业文化支持)</li></ul><h3 id="313-敏捷软件开发生命周期"><a class="markdownIt-Anchor" href="#313-敏捷软件开发生命周期">#</a> 3.1.3 敏捷软件开发生命周期</h3><p>需求分析 → 设计 → 编程 / CI → 测试</p><h3 id="314-ai驱动的开发模式"><a class="markdownIt-Anchor" href="#314-ai驱动的开发模式">#</a> 3.1.4 AI 驱动的开发模式</h3><p>AI 分析工具 → AI 驱动架构与设计 → AI 编程助手和生成器 → AI 测试工具</p><h2 id="32-习题"><a class="markdownIt-Anchor" href="#32-习题">#</a> 3.2 习题</h2><ol><li>下面哪种敏捷实践使用率最高：Scrum</li><li>项目初期，一个项目需求不明确的情况下，应避免采用哪种生存期模型：V 模型</li></ol><h1 id="四-软件需求管理-6"><a class="markdownIt-Anchor" href="#四-软件需求管理-6">#</a> 四、软件需求管理 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 6</h1><h2 id="41-相关定义"><a class="markdownIt-Anchor" href="#41-相关定义">#</a> 4.1 相关定义</h2><h3 id="411-需求建模的基本方法"><a class="markdownIt-Anchor" href="#411-需求建模的基本方法">#</a> 4.1.1 需求建模的基本方法</h3><ul><li>原型方法</li><li>基于数据流建模 - 结构化分析法 (数据流图 (DFD)，系统流程图，E-R 图)</li><li>基于 UML 建模 - 面向对象的用例分析法 (用例图，时序图，状态图 (泳道图))</li><li>敏捷需求分析</li></ul><h3 id="412-需求管理"><a class="markdownIt-Anchor" href="#412-需求管理">#</a> 4.1.2 需求管理</h3><ul><li>传统需求管理：</li></ul><ol><li>前提：需求比较稳定</li><li>描述方法：数据流、UML</li><li>管理：需求变更管理流程</li></ol><ul><li>敏捷需求管理：</li></ul><ol><li>前提：需求不稳定</li><li>描述方法：User Story、BDD</li><li>管理：优先级迭代式管理</li></ol><h3 id="413-需求分析"><a class="markdownIt-Anchor" href="#413-需求分析">#</a> 4.1.3 需求分析</h3><ul><li>需求分析是为最终用户所看到的系统建立一个概念模型，是对需求的抽象描述。</li></ul><h3 id="414-需求变更管理"><a class="markdownIt-Anchor" href="#414-需求变更管理">#</a> 4.1.4 需求变更管理</h3><ul><li>确定需求变更控制过程</li><li>建立变更控制委员会 (SCCB)</li><li>进行需求变更影响分析</li><li>跟踪所有受需求变更影响的工作产品</li><li>建立需求基准版本和需求控制版本文档</li><li>维护需求变更的历史记录</li><li>跟踪每项需求的状态</li><li>衡量需求稳定性</li></ul><h3 id="415-软件需求管理过程"><a class="markdownIt-Anchor" href="#415-软件需求管理过程">#</a> 4.1.5 软件需求管理过程</h3><ul><li>需求获取</li><li>需求分析</li><li>需求规格编写</li><li>需求验证</li><li>需求变更</li></ul><h3 id="416-bdd行为驱动开发"><a class="markdownIt-Anchor" href="#416-bdd行为驱动开发">#</a> 4.1.6 BDD (行为驱动开发)</h3><ul><li>使用简单的语法格式成为 Gherkin：</li></ul><ol><li>GIVEN <a situation></li><li>WHEN <an event></li><li>THEN <expected result></li></ol><h3 id="417-用户故事"><a class="markdownIt-Anchor" href="#417-用户故事">#</a> 4.1.7 用户故事</h3><ul><li>用户故事地图：</li></ul><ol><li>横坐标：业务流程时间线，纵坐标：商业价值 (高→低)</li><li>右侧的发布阶段，发布 1 为 MVP (最小化可行产品)</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/b4d7b3ea-6240-430a-a5d5-a4d1db79a802/%E6%88%AA%E5%B1%8F2024-12-22_04.53.59.png" alt="截屏2024-12-22 04.53.59.png"></p><ul><li>用户故事是对功能的简短、简单的描述。它们通常遵循一个简单的模板：</li></ul><ol><li>As a <type of user></li><li>I want <some goal></li><li>so that <some reason></li></ol><h3 id="418-moscow"><a class="markdownIt-Anchor" href="#418-moscow">#</a> 4.1.8 MoSCoW</h3><ul><li>DSDM（动态系统开发方法）推崇的一种优先排序方法。元素包括：</li></ul><ol><li>必须要有：必须实现的功能，否则系统将无法运行。</li><li>应该有：功能很重要，但如果出现时间或资源约束，可以省略这些功能。</li><li>可能有：功能可以增强系统的功能，但其交付时间不是很关键。</li><li>想要有：功能仅服务于有限的用户群体，并且不会产生与前面项目相同的业务价值。</li></ol><h3 id="419-影响地图"><a class="markdownIt-Anchor" href="#419-影响地图">#</a> 4.1.9 影响地图</h3><ul><li>模版：从左到右分别为业务目标，角色，影响，功能项</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/7f69e545-2c98-411b-b9ba-6baa4327df67/%E6%88%AA%E5%B1%8F2024-12-22_04.52.20.png" alt="截屏2024-12-22 04.52.20.png"></p><h3 id="4110-数据流图dfd"><a class="markdownIt-Anchor" href="#4110-数据流图dfd">#</a> 4.1.10 数据流图 (DFD)</h3><ul><li><p>展示系统中的数据是如何加工处理和流动</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/99932cb7-f0a0-4da7-8c3e-72834352cb9b/%E6%88%AA%E5%B1%8F2024-12-22_05.02.47.png" alt="截屏2024-12-22 05.02.47.png"></p></li></ul><h2 id="42-习题"><a class="markdownIt-Anchor" href="#42-习题">#</a> 4.2 习题</h2><ol><li>不属于项目需求管理过程的是：需求更新</li><li>MoSCoW 是评价用户故事的一个标准 ❌</li><li>‏需求是指用户对软件的功能和性能的要求，就是用户希望软件能做什么事情，完成什么样的功能，达到什么性能 ✅</li><li>数据流分析方法是一种自下而上的分析方法 ❌</li><li>用例需求分析方法采用一种面向过程的情景分析方法 ❌</li><li>软件项目系统的响应时间属于功能性需求 ❌</li><li>Product Backlog 是敏捷项目需求的来源 ✅</li><li>下列不属于 UML 需求视图的是：甘特图 (属于：用例图，状态图，顺序图)</li><li>下列哪一项不属于结构化分析技术：系统用例图 (属于：数据流图，数据字典，系统流程图)</li><li>下列不属于软件需求范畴的是：软件采用什么样的技术实现</li><li>敏捷项目的需求一般采用什么方式描述：Story</li></ol><h1 id="五-任务分解-9"><a class="markdownIt-Anchor" href="#五-任务分解-9">#</a> 五、任务分解 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 9</h1><h2 id="51-相关定义"><a class="markdownIt-Anchor" href="#51-相关定义">#</a> 5.1 相关定义</h2><h3 id="511-wbs任务分解结构全部需求"><a class="markdownIt-Anchor" href="#511-wbs任务分解结构全部需求">#</a> 5.1.1 WBS (任务分解结构，全部需求)</h3><ul><li>WBS 组织并定义了整个项目的范围</li><li>WBS 是面向交付成果的</li><li>WBS 是对项目由粗到细的分解过程</li><li>图表、清单、字典 (标识号、名称、说明、描述、流程) 形式</li></ul><h3 id="512-工作包work-packages"><a class="markdownIt-Anchor" href="#512-工作包work-packages">#</a> 5.1.2 工作包 (work packages)</h3><ul><li>一个工作包是 WBS 的最低层次的可交付成果的集合</li><li>工作包应当由唯一主体负责</li><li>每个工作包都必须有一个提交物</li></ul><h3 id="513-分解方法"><a class="markdownIt-Anchor" href="#513-分解方法">#</a> 5.1.3 分解方法</h3><ul><li>类比、模版参照、自上而下、自下而上</li></ul><h3 id="514-敏捷项目任务分解"><a class="markdownIt-Anchor" href="#514-敏捷项目任务分解">#</a> 5.1.4 敏捷项目任务分解</h3><ul><li>基于 story 的任务分解</li><li>Story Map (渐进式需求)</li></ul><h3 id="515-story"><a class="markdownIt-Anchor" href="#515-story">#</a> 5.1.5 Story</h3><ul><li>用户故事的特点是它们可以在不同细节层次上编写</li></ul><h3 id="516-epic"><a class="markdownIt-Anchor" href="#516-epic">#</a> 5.1.6 Epic</h3><ul><li>大型用户故事通常被称为 Epic</li><li>因为一个 Epic 通常对于敏捷团队来说在一个迭代中完成太大，所以它被分解成多个较小的用户故事，然后才会进行工作</li></ul><h2 id="52-习题"><a class="markdownIt-Anchor" href="#52-习题">#</a> 5.2 习题</h2><ol><li>WBS 提供了项目范围基线 ✅</li><li>一个工作包可以分配给另外一个项目经理去完成 ✅</li><li>自上而下的任务分解方法从特殊到一般的方向进行，首先定义一些特殊的任务，然后将这些任务组织起来，形成更高级别的 WBS 层 ❌</li><li>WBS 的最高层次的可交付成果是工作包 ✅</li><li>敏捷项目的一个<strong> Epics</strong> 还可以继续分解为一些 Story ✅</li><li>WBS 确定了项目的范围 ✅</li></ol><h1 id="六-项目成本计划项目估算-10"><a class="markdownIt-Anchor" href="#六-项目成本计划项目估算-10">#</a> 六、项目成本计划 (项目估算) - - - - - - - - - - - - - - - - - - - - - 10</h1><h2 id="61-相关定义"><a class="markdownIt-Anchor" href="#61-相关定义">#</a> 6.1 相关定义</h2><h3 id="611-估算过程"><a class="markdownIt-Anchor" href="#611-估算过程">#</a> 6.1.1 估算过程</h3><p>规模估算→工作量估算→成本估算</p><h3 id="612-软件规模单位"><a class="markdownIt-Anchor" href="#612-软件规模单位">#</a> 6.1.2 软件规模单位</h3><ul><li>LOC (源代码长度)</li><li>FP (功能点数量)</li></ul><h3 id="613软件工作量单位"><a class="markdownIt-Anchor" href="#613软件工作量单位">#</a> 6.1.3 软件工作量单位</h3><ul><li>人月 (=22 人天)</li><li>人天 (=8 人时)</li><li>人年</li></ul><h3 id="614-传统估算方法"><a class="markdownIt-Anchor" href="#614-传统估算方法">#</a> 6.1.4 传统估算方法</h3><ul><li>代码行估算法</li><li>功能点估算法</li><li>用例点估算法</li><li>类比（自顶向下) 估算法</li><li>自下而上估算法</li><li>三点估算法</li><li>参数估算法</li><li>专家估算法</li></ul><h3 id="615-功能点估算"><a class="markdownIt-Anchor" href="#615-功能点估算">#</a> 6.1.5 功能点估算</h3><ul><li>用系统的功能数量来测量其规模</li><li>通过评估、加权、量化得出功能点</li><li>功能点估算方法：IFPUG、NESMA、COSMIC</li></ul><h3 id="616-ifpug"><a class="markdownIt-Anchor" href="#616-ifpug">#</a> 6.1.6 IFPUG</h3><ul><li>FP = UFP * TCF (UFP：未调整功能点计数，TCF：技术复杂度因子)</li><li>UFP：</li><li>数据功能（Data Functions）<strong>：</strong> 即用户与系统交互时操作的数据。包括以下几种：</li></ul><ol><li>内部逻辑文件（ILF，Internal Logical File）<strong>：</strong> 系统内部存储的用户数据。</li><li>外部接口文件（EIF，External Interface File）<strong>：</strong> 外部系统传入的、被系统使用的文件。</li></ol><ul><li>事务功能（Transaction Functions）<strong>：</strong> 即用户与系统交互的处理流程。包括以下几种：</li></ul><ol><li>外部输入（EI，External Input）<strong>：</strong> 用户向系统输入数据。</li><li>外部输出（EO，External Output）<strong>：</strong> 系统向外部输出的数据。</li><li>外部查询（EQ，External Query）<strong>：</strong> 用户查询系统并获取数据的操作。</li></ol><ul><li>为每个功能分配复杂度 **：** 每个功能（数据功能和事务功能）根据其复杂度进行分类。复杂度分类通常为：</li></ul><ol><li>低（Low）<strong>：</strong> 功能相对简单，处理的元素少。</li><li>中（Average）<strong>：</strong> 功能中等复杂，处理的元素数量适中。</li><li>高（High）<strong>：</strong> 功能非常复杂，处理的数据量大，涉及的逻辑复杂。</li></ol><ul><li>功能计数项的复杂度等级</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/15955f83-ba77-4344-9a11-282a0e97d063/%E6%88%AA%E5%B1%8F2024-12-22_05.32.11.png" alt="截屏2024-12-22 05.32.11.png"></p><ol><li>用每个等级的数量 * 复杂度对应的功能点数，其相加和为 UFP</li></ol><ul><li>TCF：</li><li>TCF = 0.65 + 0.01(sum(Fi))：Fi：0-5，TCF：0.65-1.35</li><li>技术复杂度因子</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/ca5669dc-feb6-4478-8b4c-872557cf9a1f/%E6%88%AA%E5%B1%8F2024-12-22_05.40.53.png" alt="截屏2024-12-22 05.40.53.png"></p><ul><li>技术复杂度因子取值范围</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/cf607d24-2dc3-4975-95df-51ceba20161e/%E6%88%AA%E5%B1%8F2024-12-22_05.41.20.png" alt="截屏2024-12-22 05.41.20.png"></p><h3 id="617-nesma"><a class="markdownIt-Anchor" href="#617-nesma">#</a> 6.1.7 NESMA</h3><ul><li>借鉴 IFPUG，并与 IFPUG 方法兼容</li><li>三种类型的功能点估算：</li></ul><ol><li>指示功能点计数：ILF * 35 + EIF * 15</li><li>估算功能点计数：UFP = (7 * ILF + 5 * EIL + 4 * EI + 5 * EO + 4 * EQ)</li><li>详细功能点计数：同 IFPUG</li><li><strong>实在不会：凭感觉直接写用例对应的功能点</strong></li></ol><h3 id="618-cosmic"><a class="markdownIt-Anchor" href="#618-cosmic">#</a> 6.1.8 COSMIC</h3><ul><li>软件需求理解为由若干个功能过程组成，关注每个功能过程所引起的数据移动，这些数据移动计为功能点。</li><li>例如：数据入、数据出、读写数据都算作功能点</li></ul><h3 id="619-gbt-36964-2018-成本计算模型"><a class="markdownIt-Anchor" href="#619-gbt-36964-2018-成本计算模型">#</a> 6.1.9 GB/T 36964-2018 成本计算模型</h3><ul><li>SDC = (S * PDR) * SWF * RDF * F + DNC</li><li>软件研发成本 = （软件规模 * 生产率） * 软件因素调整因子 * 开发因素调整因子 * 人力成本费率 + 直接非人力成本</li><li>软件规模估算：功能点估算，例如 NESMA</li><li>软件规模调整：</li></ul><ol><li>S = UFP * GSC * CF</li><li>S：调整后的功能点数； UFP：未调整的功能点数； GSC：一般性系统特征调整因子 CF：需求变更调整因子，取值见表参考行业基准数据报告</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/49f7d55f-21c9-4032-8a54-39471f89b578/%E6%88%AA%E5%B1%8F2024-12-23_04.26.28.png" alt="截屏2024-12-23 04.26.28.png"></p><ul><li>软件开发工作量估算：</li></ul><ol><li>AE = (PDR * S) * SWF * RDF</li><li>AE: 调整后的估算工作量，单位为人时； S: 调整后的软件规模，单位为功能点数； PDR: 生产率，单位为人时 / 功能点，生产率可取软件行业基准数据报告中全行业生产率的 50 中位值； SWF: 软件因素调整因子，包含业务领域、应用类型及质量特性调整因子，取值详见表； RDF: 开发因素调整因子，包括开发语言、团队经验，取值详见表。</li><li>软件因素调整因子 SWF</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/74e313b2-6e26-477f-aff9-53faa80fdb74/%E6%88%AA%E5%B1%8F2024-12-23_04.28.41.png" alt="截屏2024-12-23 04.28.41.png"></p><ol><li>开发因素调整因子 RDF</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/523b9454-1da1-44fa-8938-5fc3b5d75ff2/%E6%88%AA%E5%B1%8F2024-12-23_04.29.03.png" alt="截屏2024-12-23 04.29.03.png"></p><ul><li>软件开发费用估算：</li></ul><ol><li>P = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>A</mi><mi>E</mi></mrow><mrow><mi>H</mi><mi>M</mi><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{AE}{HM2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> * F2 + DNC</li><li>P：软件开发费用，单位为万元。 AE：调整后工作量，单位为人时。 HM2 ：人月折算系数，单位为人时 / 人月，取值为 174 (21.75 天 x8 人时 / 天 = 174 人时)。 F2：人月基准单价，单位为万元 / 人月，取值见表 6-20。 DNC：直接非人力成本，单位为万元；直接非人力成本由委托方根据实际情况进行分析估算。</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/a696525b-53c9-4847-91b9-88908855dffe/%E6%88%AA%E5%B1%8F2024-12-23_04.30.23.png" alt="截屏2024-12-23 04.30.23.png"></p><ul><li>功能点与代码行转换</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/9786fbd1-b92d-46a5-9381-56ae90dcaa5c/%E6%88%AA%E5%B1%8F2024-12-23_04.32.38.png" alt="截屏2024-12-23 04.32.38.png"></p><ul><li><strong>实在不会：人力成本 150 * 功能点数量</strong></li><li>待补充</li></ul><h3 id="6110-用例点估算法"><a class="markdownIt-Anchor" href="#6110-用例点估算法">#</a> 6.1.10 用例点估算法</h3><ul><li>计算未调整的角色权制 UAW</li></ul><ol><li>UAW = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>C</mi><mo>=</mo><mi>c</mi></mrow></msub><mi>a</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>a</mi><mi>C</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∑_{C=c}aWeight(C) * aCardinality(c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">aW</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mord mathnormal">ina</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/74e86622-0847-4638-b1f6-36097e5a2132/%E6%88%AA%E5%B1%8F2024-12-23_04.38.29.png" alt="截屏2024-12-23 04.38.29.png"></p><ul><li>计算未调整的用例权值</li></ul><ol><li>UUCW = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>C</mi><mo>=</mo><mi>c</mi></mrow></msub><mi>u</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>u</mi><mi>C</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∑_{C=c}uWeight(C) * uCardinality(c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">d</span><span class="mord mathnormal">ina</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/6e815e8e-cfa0-46f8-ae57-c3f7ec7dda3d/%E6%88%AA%E5%B1%8F2024-12-23_04.38.38.png" alt="截屏2024-12-23 04.38.38.png"></p><ul><li>计算未调整的用例点 UUCP</li></ul><ol><li>UUCP = UAW + UUCW</li></ol><ul><li>计算技术和环境因子 TEF</li></ul><ol><li>计算技术因子 TCF = 0.6 + (0.01 * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>13</mn></msubsup><mi>T</mi><mi>C</mi><mi>F</mi><mi mathvariant="normal">_</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>i</mi></msub><mo>∗</mo><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">∑^{13}_{i=1}TCF\_Weight_i * Value_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.264em;vertical-align:-0.31em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">TCF</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/a30fe723-a302-432b-92a3-766ede80d489/%E6%88%AA%E5%B1%8F2024-12-23_04.40.47.png" alt="截屏2024-12-23 04.40.47.png"></p><ol><li>计算环境因子 ECF = 1.4 + (-0.03 * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>8</mn></msubsup><mi>E</mi><mi>C</mi><mi>F</mi><mi mathvariant="normal">_</mi><mi>W</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>i</mi></msub><mo>∗</mo><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">∑^8_{i=1}ECF\_Weight_i * Value_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.264em;vertical-align:-0.31em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">ECF</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">Va</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/a625b801-be00-4f9a-a24c-fe7a99840496/%E6%88%AA%E5%B1%8F2024-12-23_04.45.15.png" alt="截屏2024-12-23 04.45.15.png"></p><ul><li>计算调整的用例点 UCP</li></ul><ol><li>UCP = UUCP * TCP * ECF</li></ol><ul><li>计算工作量 (man-hours)</li></ul><ol><li>Effort = UCP * PF</li><li>一般假设 PF = 20 工时 / 用例点</li></ol><p>待补充</p><h3 id="6111-类比自顶向下估算法"><a class="markdownIt-Anchor" href="#6111-类比自顶向下估算法">#</a> 6.1.11 类比 (自顶向下) 估算法</h3><p>估算人员根据以往的完成类似项目所消耗的总成本（或工作量），来推算将要开发的软件的总成本（或工作量）</p><h3 id="6112-自下而上估算法"><a class="markdownIt-Anchor" href="#6112-自下而上估算法">#</a> 6.1.12 自下而上估算法</h3><p>利用任务分解图 (WBS)，对各个具体工作包进行详细的成本估算，然后将结果累加起来得出项目总成本。</p><h3 id="6113-三点估算法"><a class="markdownIt-Anchor" href="#6113-三点估算法">#</a> 6.1.13 三点估算法</h3><ul><li>最可能成本（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">C_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>) : 比较现实的估算成本。</li><li>最乐观成本（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>O</mi></msub></mrow><annotation encoding="application/x-tex">C_O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>): 最好情况所得到的估算成本。</li><li>最悲观成本（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">C_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>): 最差情况所得到的估算成本。</li><li>三点估算结果：</li></ul><ol><li>三角分布：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>E</mi></msub></mrow><annotation encoding="application/x-tex">C_E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>O</mi></msub></mrow><annotation encoding="application/x-tex">C_O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">C_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">C_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)/3</li><li>贝塔分布：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>E</mi></msub></mrow><annotation encoding="application/x-tex">C_E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>O</mi></msub></mrow><annotation encoding="application/x-tex">C_O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + 4<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">C_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">C_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)/6</li></ol><h3 id="6114-参数估算法cocomo"><a class="markdownIt-Anchor" href="#6114-参数估算法cocomo">#</a> 6.1.14 参数估算法 (COCOMO)</h3><ul><li>E = a + b * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mi>c</mi></msup></mrow><annotation encoding="application/x-tex">S^c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span></span></span></span></span></span></span> * M</li><li>E：以人月表示的工作量</li><li>a，b，c：经验导出的系数</li><li>M：调节因子</li><li>S：主要的输入参数</li><li>COCOMO：E = 3.2 *<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><mi>L</mi><mi>O</mi><mi>C</mi><msup><mo stretchy="false">)</mo><mn>1.05</mn></msup></mrow><annotation encoding="application/x-tex">(KLOC)^{1.05}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1.05</span></span></span></span></span></span></span></span></span></span></span></span> (模型等级：基本、中等、高级)</li></ul><table><thead><tr><th>方式</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>有机</td><td>2.4</td><td>1.05</td></tr><tr><td>半有机</td><td>3.0</td><td>1.12</td></tr><tr><td>嵌入式</td><td>3.6</td><td>1.2</td></tr></tbody></table><ul><li>Walston-Felix(IBM)：E = 5.2 *<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><mi>L</mi><mi>O</mi><mi>C</mi><msup><mo stretchy="false">)</mo><mn>0.91</mn></msup></mrow><annotation encoding="application/x-tex">(KLOC)^{0.91}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">OC</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0.91</span></span></span></span></span></span></span></span></span></span></span></span></li><li>KLOC：源代码行数</li><li>a * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>L</mi><mi>O</mi><msup><mi>C</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">KLOC^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span></li></ul><p>待补充</p><h3 id="6115-专家估算法"><a class="markdownIt-Anchor" href="#6115-专家估算法">#</a> 6.1.15 专家估算法</h3><h3 id="6116-story-point"><a class="markdownIt-Anchor" href="#6116-story-point">#</a> 6.1.16 Story point</h3><ul><li>Story point（故事点）用来度量实现一个 Story 需要付出的工作量的相对估算。</li><li>Story point 估算 - 常用的两个标准：</li></ul><ol><li>Fibonacci: 0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</li><li>Power of 2: 0, 1, 2, 4, 8, 16, 32, 64, 128</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/da40156e-ff9c-4961-90a7-7a03549aaa47/%E6%88%AA%E5%B1%8F2024-12-22_06.19.19.png" alt="截屏2024-12-22 06.19.19.png"></p><h3 id="6117-敏捷估算方法"><a class="markdownIt-Anchor" href="#6117-敏捷估算方法">#</a> 6.1.17 敏捷估算方法</h3><ul><li>Fast Story Point Estimation：</li></ul><ol><li>基准估算参考：</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/2f924a38-f31e-42da-9e0a-77a7b05f9a97/%E6%88%AA%E5%B1%8F2024-12-22_06.22.13.png" alt="截屏2024-12-22 06.22.13.png"></p><ul><li>Planning Poker 估算方法：</li></ul><ol><li>为每个细化分解的任务分配故事点</li></ol><h2 id="62-习题"><a class="markdownIt-Anchor" href="#62-习题">#</a> 6.2 习题</h2><ol><li>三点估算的三种估算值不包括：最初始成本<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">C_I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，项目经理估算值</li><li>Story point 是一种相对估算过程 ✅</li><li>快速估算法中，Story 6 从 5、8、13 被来回挪动，最后大家讨论没有达成一致，那么 Story 6 应该放到哪里：13</li><li>功能点估算与项目所使用的语言和技术有关 ❌</li><li>COCOMO 81 的 3 个等级模型是有机型、嵌入型、半嵌入型 ❌ (有机，半有机，嵌入式)</li><li>估算时既要考虑直接成本又要考虑间接成本 ✅</li><li>下面关于估算的说法，错误的是哪项：经验对于估算来说不重要</li><li>假设某项目的注册功能为 3 个 story points，而其中成绩录入工作量比注册功能工作量略多，采用 Fibonacci 等级标准估算的话 **,** 成绩录入功能的估算值是：5 个 story point</li><li>下列不是 UFC 的功能计数项的是：内部输出</li><li>下列不是软件项目规模单位的是：人时</li></ol><h1 id="七-项目进度计划-18"><a class="markdownIt-Anchor" href="#七-项目进度计划-18">#</a> 七、项目进度计划 - - - - - - - - - - - - - - - - - - - - - - - - - - - - 18</h1><h2 id="71-相关定义"><a class="markdownIt-Anchor" href="#71-相关定义">#</a> 7.1 相关定义</h2><h3 id="711-进度"><a class="markdownIt-Anchor" href="#711-进度">#</a> 7.1.1 进度</h3><p>进度是对执行的活动和里程碑制定的工作计划日期表</p><h3 id="712-任务"><a class="markdownIt-Anchor" href="#712-任务">#</a> 7.1.2 任务</h3><ul><li>确定为完成项目的各个交付成果所必须进行的诸项具体活动</li><li>WBS 的最低层</li></ul><h3 id="713-任务关系前置活动和后置活动"><a class="markdownIt-Anchor" href="#713-任务关系前置活动和后置活动">#</a> 7.1.3 任务关系 (前置活动和后置活动)</h3><ul><li>关系依赖矩阵：</li></ul><ol><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">d_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 的前置，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>=1，否则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>=0</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/a25cc9d5-81e8-4495-86b8-6d3b8933efc2/%E6%88%AA%E5%B1%8F2024-12-22_16.19.52.png" alt="截屏2024-12-22 16.19.52.png"></p><h3 id="714-历时估算"><a class="markdownIt-Anchor" href="#714-历时估算">#</a> 7.1.4 历时估算</h3><ul><li>估计任务、路径、项目的持续时间</li><li>基本方法：</li></ul><ol><li>定额估算法</li><li>经验导出模型</li><li>CPM (关键路径法估计)</li><li>PERT (工程评估评审技术)</li><li>预留分析</li></ol><h3 id="715-定额估算法"><a class="markdownIt-Anchor" href="#715-定额估算法">#</a> 7.1.5 定额估算法</h3><ul><li>T = Q / (R * S)</li><li>T：活动历时，Q：任务工作量，R：人力数量，S：工作效率</li></ul><h3 id="716-经验导出模型"><a class="markdownIt-Anchor" href="#716-经验导出模型">#</a> 7.1.6 经验导出模型</h3><ul><li>D = a * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>E</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">E^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span></li><li>D：进度 (以月单位)</li><li>E：工作量 (以人月单位)</li><li>a：2-4 之间</li><li>b：1/3 左右 (依赖于项目的自然属性)</li></ul><ol><li>Walston-Felix 模型：D = 2.4 * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>E</mi><mn>0.35</mn></msup></mrow><annotation encoding="application/x-tex">E^{0.35}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0.35</span></span></span></span></span></span></span></span></span></span></span></span></li><li>基于 COCOMO：D = 2.5 * <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>E</mi><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">E^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span></li></ol><table><thead><tr><th>方式</th><th>b</th></tr></thead><tbody><tr><td>有机</td><td>0.38</td></tr><tr><td>半有机</td><td>0.35</td></tr><tr><td>嵌入式</td><td>0.32</td></tr></tbody></table><h3 id="717-cpm关键路径法"><a class="markdownIt-Anchor" href="#717-cpm关键路径法">#</a> 7.1.7 CPM (关键路径法)</h3><ul><li>确定项目网络图</li><li>每个任务有单一的历时估算</li><li>确定网络图中任务的逻辑关系</li><li>关键路径是网络图中最长的路径。</li><li>关键路径决定项目完成的最短时间。</li><li>关键路径：</li></ul><ol><li>网络图中最长的路径</li><li>关键路径决定项目完成的最短时间。</li><li>关键路径上任何活动延迟，都会导致整个项目完成时间的延迟</li><li>关键路径可能不止一条</li></ol><h3 id="718-pert工程评估评审"><a class="markdownIt-Anchor" href="#718-pert工程评估评审">#</a> 7.1.8 PERT (工程评估评审)</h3><ul><li>选定 3 个估算值：</li></ul><ol><li>0 是最小估算值：乐观 (Optimistic)，</li><li>P 是最大估算值：悲观 (Pessimistic)，</li><li>M 是最大可能估算 (Most Likely)。</li></ol><ul><li>采用加权平均得到期望值 E= O+4m+P)/6</li><li>标准差 = (最大估算值 - 最小估算值)/6</li></ul><h3 id="719-预留分析"><a class="markdownIt-Anchor" href="#719-预留分析">#</a> 7.1.9 预留分析</h3><ul><li>应给预留：应急预留是包含在进度基准中的一段储备时间，用来应对已经接受的已识别风险，以应对进度方面的不确定性。</li><li>管理预留：管理预留是为管理控制的目的而特别留出的项目预算，用来应对项目范围中不可预见的风险。</li></ul><h3 id="7110-jones的一阶估算准则"><a class="markdownIt-Anchor" href="#7110-jones的一阶估算准则">#</a> 7.1.10 Jones 的一阶估算准则</h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>功能点数</mtext><msup><mtext>量</mtext><mtext>幂次表中的幂次</mtext></msup></mrow><annotation encoding="application/x-tex">功能点数量^{幂次表中的幂次}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord cjk_fallback">功能点数</span><span class="mord"><span class="mord cjk_fallback">量</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">幂次表中的幂次</span></span></span></span></span></span></span></span></span></span></span></span></li></ul><table><thead><tr><th>软件类型</th><th>最优级</th><th>平均</th><th>最差级</th></tr></thead><tbody><tr><td>系统软件</td><td>0.43</td><td>0.45</td><td>0.48</td></tr><tr><td>商业软件</td><td>0.41</td><td>0.43</td><td>0.46</td></tr><tr><td>封装商品软件</td><td>0.39</td><td>0.42</td><td>0.45</td></tr></tbody></table><h3 id="7111-网络图"><a class="markdownIt-Anchor" href="#7111-网络图">#</a> 7.1.11 网络图</h3><ul><li>PDM (优先图法，节点法)</li></ul><ol><li>构成 PDM 网络图的基本特点是节点 (Box)</li><li>节点 (Box) 表示活动（任务）</li><li>用箭线表示各活动 (任务) 之间的逻辑关系</li><li>可以方便的表示活动之间的各种逻辑关系</li></ol><ul><li>ADM (箭线法)</li></ul><ol><li>ADM 也称为双代号项目网络图</li><li>在 ADM 网络图中，箭线表示活动 (任务)</li><li>两个代号唯一确定一个任务</li><li>代号表示前一任务的结束，同时也表示后一任务的开始</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/b3996d09-fffe-4f84-abee-eaf8fed38761/%E6%88%AA%E5%B1%8F2024-12-22_21.01.44.png" alt="截屏2024-12-22 21.01.44.png"></p><h3 id="7112-传统进度编制的基本方法"><a class="markdownIt-Anchor" href="#7112-传统进度编制的基本方法">#</a> 7.1.12 传统进度编制的基本方法</h3><ul><li>超前 (lead) 与滞后 (lag)</li><li>关键路径法 (时间浮动 = 0)</li></ul><ol><li>最早开始时间 (Early start)</li><li>最晚开始时间 (Late start)</li><li>最早完成时间 (Early finish)</li><li>最晚完成时间 (Late finish)</li><li>总浮动 (Total Float)：在不影响项目最早完成时间的前提下，一个任务可以延迟的时间</li><li>自由浮动 (Free Float)：在不影响后置任务最早开始时间的前提下，一个任务可以延迟的时间</li></ol><ul><li>正推法：ES + Duration = EF，EF + Lag = ES (s)(选择前置任务中最大的 EF 加上 Lag 作为 ES)</li><li>逆推法：LF - Duration = LS，LS - Lag = LF (p)(选择后置任务中最小的 LS 减 Lag 作为 LF)</li><li>时间压缩法</li></ul><ol><li>在不改变项目范围的前提下缩短项目工期的方法</li><li>应急法：赶工</li><li>平行作业法：快速跟进</li></ol><h3 id="7113-资源优化"><a class="markdownIt-Anchor" href="#7113-资源优化">#</a> 7.1.13 资源优化</h3><ul><li>资源平衡 (调整任务时间来协调资源冲突，导致关键路径改变)</li><li>资源平滑 (不会干扁关键路径)</li></ul><h3 id="7114-敏捷计划编排"><a class="markdownIt-Anchor" href="#7114-敏捷计划编排">#</a> 7.1.14 敏捷计划编排</h3><ul><li>Release planning：发布计划 (远期，粗)</li><li>Iteration planning：迭代计划 (近期，细)</li></ul><h2 id="72-习题"><a class="markdownIt-Anchor" href="#72-习题">#</a> 7.2 习题</h2><ol><li>关键路径是网络图中最短路径 ❌</li><li>项目在 14.57 天内完成的概率：84.2%</li><li>下面哪项是包含在进度基准中的一段储备时间：应给预留</li><li>网络图中最短路径是项目完成的最短时间 ❌</li><li>Charles Symons 进度压缩因子方法认为：进度最懂应该压缩：25%</li><li>哪个资源优化方法经常导致关键路径改变：资源平衡</li><li>下面描述 Scrum Velocity 含义不正确的是：每个迭代的时间长度</li><li>下面不是敏捷进度管理工具：甘特图</li><li>快速跟进是指：采用并行执行任务，加速项目进展</li><li>下面哪一项将延长项目的进度：lag</li><li>下面哪一项可以决定进度的灵活性：总浮动</li><li>下面哪个图示可以表示敏捷项目进度，并且可以表示出剩余的任务：燃尽图</li><li>浮动是在不增加项目成本的条件下，一个活动可以延迟的时间量 ❌</li><li>在使用应急法压缩时间时，不一定要在关键路径上选择活动来进行压缩 ❌</li><li>敏捷项目一般采取远粗近细的计划模式，敏捷的发布计划相当于远期计划，迭代计划相当于近期计划 ✅</li></ol><h1 id="八-项目质量计划-21"><a class="markdownIt-Anchor" href="#八-项目质量计划-21">#</a> 八、项目质量计划 - - - - - - - - - - - - - - - - - - - - - - - - - - - - 21</h1><h2 id="81-相关定义"><a class="markdownIt-Anchor" href="#81-相关定义">#</a> 8.1 相关定义</h2><h3 id="811-软件质量"><a class="markdownIt-Anchor" href="#811-软件质量">#</a> 8.1.1 软件质量</h3><p>软件满足明确说明或隐含的需求的程度</p><h3 id="812-质量成本coq"><a class="markdownIt-Anchor" href="#812-质量成本coq">#</a> 8.1.2 质量成本 (CoQ)</h3><ul><li>预防成本：前期质量成本</li><li>缺陷成本：后期质量成本</li></ul><h3 id="813-质量控制qc"><a class="markdownIt-Anchor" href="#813-质量控制qc">#</a> 8.1.3 质量控制 (QC)</h3><ul><li>确定项目结果与质量标准是否相符，同时，确定不符的原因和消除方法</li><li>控制产品的质量，及时纠正缺陷</li><li>例如：代码评审、单元测试</li><li>代码检查：Pair Programming TDD (Test Driven Development) 持续集成、测试 不同层面测试（自动化测试） 迭代评审 验收测试驱动开发 (ATDD) Refactor</li></ul><h3 id="814-质量保证qa"><a class="markdownIt-Anchor" href="#814-质量保证qa">#</a> 8.1.4 质量保证 (QA)</h3><ul><li>通过评价项目整体绩效，建立对质量要求的信任</li><li>提供项目和产品可视化的管理报告</li><li>例如: 《软件设计说明书》质量审计</li></ul><h3 id="815-软件质量计划"><a class="markdownIt-Anchor" href="#815-软件质量计划">#</a> 8.1.5 软件质量计划</h3><ul><li>确定项目应达到的质量标准 (目标)</li><li>决定如何满足质量标准的计划安排和方法</li></ul><h3 id="816-敏捷项目的质量活动"><a class="markdownIt-Anchor" href="#816-敏捷项目的质量活动">#</a> 8.1.6 敏捷项目的质量活动</h3><ul><li>结对编程</li><li>TDD</li><li>ATDD</li><li>Refactor</li><li>CI/CD</li><li>不同层面测试</li></ul><h3 id="817-tdd"><a class="markdownIt-Anchor" href="#817-tdd">#</a> 8.1.7 TDD</h3><p>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码，然后编写相关的代码满足这些测试用例</p><h3 id="818-atdd"><a class="markdownIt-Anchor" href="#818-atdd">#</a> 8.1.8 ATDD</h3><p>与客户一起讨论验收标准，创建测试用例，据此驱动代码编写，进行自动化测试，满足验收标准</p><h2 id="82-习题"><a class="markdownIt-Anchor" href="#82-习题">#</a> 8.2 习题</h2><ol><li>高质量的软件是通过不断的系统测试实现的 ❌</li><li>软件质量可以通过后期测试得以提高 ❌</li><li>软件质量是代码正确的程度 ❌</li><li>敏捷项目提倡全程的质量审查 ✅</li><li>下列哪项不是软件质量模型：关键路径模型</li><li>下面哪项不是敏捷项目的质量实践： 需求规格编写过程</li></ol><h1 id="九-配置管理计划-22"><a class="markdownIt-Anchor" href="#九-配置管理计划-22">#</a> 九、配置管理计划 - - - - - - - - - - - - - - - - - - - - - - - - - - - - 22</h1><h2 id="91-相关定义"><a class="markdownIt-Anchor" href="#91-相关定义">#</a> 9.1 相关定义</h2><h3 id="911-配置管理"><a class="markdownIt-Anchor" href="#911-配置管理">#</a> 9.1.1 配置管理</h3><ul><li>记录产品的演化过程</li><li>得到精确的产品配置</li><li>保证软件产品的完整性、一致性、追溯性、可控性</li><li>主要功能：</li></ul><ol><li>版本管理</li><li>变更管理</li><li>过程支持</li></ol><h3 id="912-软件配置项"><a class="markdownIt-Anchor" href="#912-软件配置项">#</a> 9.1.2 软件配置项</h3><ul><li>SCI：受控于软件配置管理的细目</li><li>被唯一标识 (企业 - 项目 - 分组 - 类型 - 版本号)</li></ul><h3 id="913-基线"><a class="markdownIt-Anchor" href="#913-基线">#</a> 9.1.3 基线</h3><p>提供了软件生存期中各个开发阶段的一个特定点，标志开发过程一个阶段的结束或里程碑</p><h3 id="914-软件配置控制委员会sccb"><a class="markdownIt-Anchor" href="#914-软件配置控制委员会sccb">#</a> 9.1.4 软件配置控制委员会 (SCCB)</h3><ul><li>评估变更</li><li>批准变更申请</li><li>在生存期内规范变更申请流程</li><li>对变更进行反馈</li><li>与项目管理层沟通</li></ul><h3 id="915-配置管理环境"><a class="markdownIt-Anchor" href="#915-配置管理环境">#</a> 9.1.5 配置管理环境</h3><p>建立配置管理库</p><h3 id="916-基线变更系统"><a class="markdownIt-Anchor" href="#916-基线变更系统">#</a> 9.1.6 基线变更系统</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/32d4d7ec-b5dd-494b-83de-4db070ac73fa/%E6%88%AA%E5%B1%8F2024-12-22_22.50.14.png" alt="截屏2024-12-22 22.50.14.png"></p><h3 id="917-版本控制"><a class="markdownIt-Anchor" href="#917-版本控制">#</a> 9.1.7 版本控制</h3><p>配置管理工具</p><h3 id="918-敏捷配置管理"><a class="markdownIt-Anchor" href="#918-敏捷配置管理">#</a> 9.1.8 敏捷配置管理</h3><ul><li>持续交付</li><li>需要全面配置管理</li></ul><h3 id="919-全面配置管理"><a class="markdownIt-Anchor" href="#919-全面配置管理">#</a> 9.1.9 全面配置管理</h3><ul><li>代码和编译构建产物的配置管理：</li></ul><ol><li>制定有效的分支管理策略：基于分支、主干的开发</li><li>配置管理工具</li></ol><ul><li>核心配置管理</li></ul><p>CI/CD 工具链</p><h2 id="92-习题"><a class="markdownIt-Anchor" href="#92-习题">#</a> 9.2 习题</h2><ol><li>基线不能修改 ❌</li><li>敏捷的一个重要特征是持续交付 ✅</li><li>在持续交付领域，强调对项目所有的相关产物及其之间的关系都要进行有效配置管理 ✅</li><li>持续交付更倾向使用基于分支的开发模式 ❌</li><li>一个软件配置项可能有多个标识 ❌</li><li>以下哪项不是项目配置管理中可能遇到的问题：甲方与乙方在资金调配上存在意见差异</li></ol><h1 id="十-团队计划-24"><a class="markdownIt-Anchor" href="#十-团队计划-24">#</a> 十、团队计划 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 24</h1><h2 id="101-相关定义"><a class="markdownIt-Anchor" href="#101-相关定义">#</a> 10.1 相关定义</h2><h3 id="1011-人员职责计划"><a class="markdownIt-Anchor" href="#1011-人员职责计划">#</a> 10.1.1 人员职责计划</h3><ul><li>责任分配矩阵 (RAM)</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/b8a32f29-8a95-492f-9e1d-9ef55a906e85/%E6%88%AA%E5%B1%8F2024-12-22_23.18.54.png" alt="截屏2024-12-22 23.18.54.png"></p><ul><li>组织分解结构 (OBS) 与 WBS</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/dec17f2e-7db1-462d-807e-e494351510c8/%E6%88%AA%E5%B1%8F2024-12-22_23.23.11.png" alt="截屏2024-12-22 23.23.11.png"></p><p>负责任的组织单位 执行组织单位</p><ul><li>文本型</li></ul><h3 id="1012-项目角色"><a class="markdownIt-Anchor" href="#1012-项目角色">#</a> 10.1.2 项目角色</h3><ul><li>项目经理</li><li>系统分析员</li><li>系统设计员</li><li>数据库管理员</li><li>支持工程师</li><li>程序员</li><li>质量保证人员</li><li>配置管理人员</li><li>业务专家（用户）</li><li>测试人员</li></ul><h3 id="1013-干系人"><a class="markdownIt-Anchor" href="#1013-干系人">#</a> 10.1.3 干系人</h3><p>干系人（stakeholder）是能影响项目决策、活动或者结果的个人、群体或者组织，以及会受到或者自认为会受到项目决策、活动或者结果影响的个人、群体或者组织。</p><h3 id="1014-项目沟通计划"><a class="markdownIt-Anchor" href="#1014-项目沟通计划">#</a> 10.1.4 项目沟通计划</h3><p>沟通计划是确定谁需要信息，需要什么信息，何时需要信息，以及如何将信息分发给他们。</p><h3 id="1015-敏捷团队"><a class="markdownIt-Anchor" href="#1015-敏捷团队">#</a> 10.1.5 敏捷团队</h3><ul><li>黄金人数：5-9 人 (往往 3-9 人)</li><li>集中在一个工作场所工作</li><li>自组织团队 (100% 为专职成员)</li></ul><h3 id="1016-敏捷方法提倡高度透明沟通方式"><a class="markdownIt-Anchor" href="#1016-敏捷方法提倡高度透明沟通方式">#</a> 10.1.6 敏捷方法提倡高度透明沟通方式</h3><h3 id="1017-okr目标与关键结果"><a class="markdownIt-Anchor" href="#1017-okr目标与关键结果">#</a> 10.1.7 OKR (目标与关键结果)</h3><p>一套组织、团队与个人皆适用的目标管理方法</p><h3 id="1018-敏捷角色"><a class="markdownIt-Anchor" href="#1018-敏捷角色">#</a> 10.1.8 敏捷角色</h3><p>产品负责人，团队促进者，跨职能团队成员</p><h3 id="1019-scrum角色"><a class="markdownIt-Anchor" href="#1019-scrum角色">#</a> 10.1.9 Scrum 角色</h3><p>产品负责人，Scrum 主管，开发团队</p><h2 id="102-习题"><a class="markdownIt-Anchor" href="#102-习题">#</a> 10.2 习题</h2><ol><li>关于项目沟通渠道：越少越高效</li><li>下面哪项不是敏捷角色：合同管理者</li><li>在实践中，最有效的敏捷团队往往由三到九个成员组成，而且黄金人数是多少：5-9</li><li>项目团队原来有 5 个成员，现在人员扩充，又增加了 3 个成员，那么沟通渠道是原来的（ ）倍：2.8</li><li>对于项目中比较重要的通知，最好采用（ ）沟通方式：书面</li><li>在一个高科技公司，项目经理正在为一个新的项目选择合适的组织结构，这个项目涉及很多的领域和特性，他应该选择（ ）组织结构：矩阵型</li></ol><h1 id="十一-风险计划-25"><a class="markdownIt-Anchor" href="#十一-风险计划-25">#</a> 十一、风险计划 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 25</h1><h2 id="111-相关定义"><a class="markdownIt-Anchor" href="#111-相关定义">#</a> 11.1 相关定义</h2><h3 id="1111-风险三要素"><a class="markdownIt-Anchor" href="#1111-风险三要素">#</a> 11.1.1 风险三要素</h3><ul><li>风险事件</li><li>事件概率</li><li>事件影响</li></ul><h3 id="1112-风险类型"><a class="markdownIt-Anchor" href="#1112-风险类型">#</a> 11.1.2 风险类型</h3><ul><li>预测角度：</li></ul><ol><li>已知风险</li><li>可预测风险</li><li>不可预测风险</li></ol><ul><li>范围角度</li></ul><p>商业风险、管理风险、人员风险、技术风险、开发环境风险、客户风险、过程风险、产品规模风险等。</p><h3 id="1113-风险管理的四个过程"><a class="markdownIt-Anchor" href="#1113-风险管理的四个过程">#</a> 11.1.3 风险管理的四个过程</h3><ul><li>风险识别：识别已知和可预测的风险</li><li>风险评估：对风险事件发生概率、项目风险影响的评估，给出项目风险排序</li><li>风险规划</li><li>风险控制：风险控制是在项目执行过程中监控风险，实施风险计划，同时，不断进行风险识别、风险分析、风险规划的过程。</li></ul><h3 id="1114-风险评估"><a class="markdownIt-Anchor" href="#1114-风险评估">#</a> 11.1.4 风险评估</h3><ul><li>风险值：R = F (P，I)</li><li>风险发生的概率：P</li><li>风险对项目的影响：I</li></ul><h3 id="1115-emv损益期望值"><a class="markdownIt-Anchor" href="#1115-emv损益期望值">#</a> 11.1.5 EMV (损益期望值)</h3><p>EMV = 成功的概率 * 收益</p><h3 id="1116-风险规划的主要策略"><a class="markdownIt-Anchor" href="#1116-风险规划的主要策略">#</a> 11.1.6 风险规划的主要策略</h3><ul><li>回避风险：</li></ul><ol><li>回避风险是对可能发生的风险尽可能的规避，采取主动放弃或者拒绝使用导致风险的方案</li><li>例如：放弃采用新技术</li></ol><ul><li>转移风险：</li></ul><ol><li>转移风险是为了避免承担风险损失，有意识将损失或与损失有关的财务后果转嫁出去的方法。</li><li>例如：分包，开脱责任合同，保险</li></ol><ul><li>损失控制：</li></ul><ol><li>损失预防：项目技术培训，预防技术失败</li><li>损失抑制：项目人员储备，抑制人员流失的损失</li></ol><ul><li>自留风险：由项目组织自己承担风险事故所致损失的措施</li></ul><h3 id="1117-敏捷项目风险应对方法"><a class="markdownIt-Anchor" href="#1117-敏捷项目风险应对方法">#</a> 11.1.7 敏捷项目风险应对方法</h3><ul><li>损失预防与损失抑制策略：</li></ul><ol><li>跨职能项目团队 (识别风险)</li><li>选择迭代内容 (选择风险小的)</li><li>频繁评审增量产品</li><li>持续测试可以及早发现问题</li><li>客户参与可以减少需求变更的风险</li></ol><h3 id="1118-mvp最小可行产品"><a class="markdownIt-Anchor" href="#1118-mvp最小可行产品">#</a> 11.1.8 MVP (最小可行产品)</h3><p>快速地构建出符合产品预期功能的最小功能集合可以有效降低风险</p><h3 id="1119-风险评估方法"><a class="markdownIt-Anchor" href="#1119-风险评估方法">#</a> 11.1.9 风险评估方法</h3><ul><li>模拟</li><li>决策树分析</li><li>盈亏平衡分析</li><li>敏感分析</li></ul><h2 id="112-习题"><a class="markdownIt-Anchor" href="#112-习题">#</a> 11.2 习题</h2><ol><li>需求变更属于什么风险类型：可预测风险</li><li>对新技术进行项目培训是什么风险策略：损失控制</li><li>不属于项目风险三要素的是：事件的产生原因</li><li>下列属于可预测风险的是：人员调整</li><li>下列不是风险管理过程的是：风险收集</li><li>在一个项目的开发过程中采用了新的技术，为此，项目经理找来专家对项目组人员进行技术培训，这是什么风险应对策略：损失控制</li><li>下列不属于风险评估方法的是：二叉树分析</li><li>风险是损失发生的不确定性，是对潜在的、未来可能发生损害的一种度 ✅</li><li>购买保险是一种回避风险的应对策略 ❌</li><li>敏捷项目没有长期计划，这本身也是一个风险，因为存在一些无法识别的风险 ✅</li></ol><h1 id="十二-合同计划-27"><a class="markdownIt-Anchor" href="#十二-合同计划-27">#</a> 十二、合同计划 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 27</h1><h2 id="121-相关定义"><a class="markdownIt-Anchor" href="#121-相关定义">#</a> 12.1 相关定义</h2><h3 id="1211-成本补偿合同"><a class="markdownIt-Anchor" href="#1211-成本补偿合同">#</a> 12.1.1 成本补偿合同</h3><ul><li>向卖方支付为完成工作而发生的全部合法实际成本，外加一笔费用作为卖方的利润。</li><li>这种合同适用于：工作范围预计会在合同执行期间发生重大变更。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/5290159f-800e-4bf8-b86f-4dd8a37cb75c/%E6%88%AA%E5%B1%8F2024-12-23_00.28.10.png" alt="截屏2024-12-23 00.28.10.png"></p><ul><li>CPIF：</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/e5ef250f-db49-4099-b019-b1c518e11da5/%E6%88%AA%E5%B1%8F2024-12-23_01.44.26.png" alt="截屏2024-12-23 01.44.26.png"></p><ul><li>CPAF：</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/a30d1d17-51ca-4f20-a0e8-7ccc173c151b/%E6%88%AA%E5%B1%8F2024-12-23_01.44.37.png" alt="截屏2024-12-23 01.44.37.png"></p><h3 id="1212-总价合同"><a class="markdownIt-Anchor" href="#1212-总价合同">#</a> 12.1.2 总价合同</h3><ul><li>总价合同为既定产品、服务或成果的采购设定一个总价。</li><li>这种合同应在已明确定义需求，且不会出现重大范围变更的情况下使用。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/181867d6-4193-4097-9aba-e36afe192b3f/%E6%88%AA%E5%B1%8F2024-12-23_00.30.28.png" alt="截屏2024-12-23 00.30.28.png"></p><ul><li>FFP：</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/d2ec6749-dfa2-4fea-87a8-3b8faa2fcbb3/%E6%88%AA%E5%B1%8F2024-12-23_01.41.53.png" alt="截屏2024-12-23 01.41.53.png"></p><ul><li>FPIF：</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/96863ab1-c4c6-4fa7-99ec-928811b26f73/%E6%88%AA%E5%B1%8F2024-12-23_01.43.28.png" alt="截屏2024-12-23 01.43.28.png"></p><h3 id="1213-合同类型与相应风险"><a class="markdownIt-Anchor" href="#1213-合同类型与相应风险">#</a> 12.1.3 合同类型与相应风险</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/7d19e875-43f0-41c5-9434-ce370f84e709/%E6%88%AA%E5%B1%8F2024-12-23_00.32.14.png" alt="截屏2024-12-23 00.32.14.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/db8d42d4-7ff1-42ca-b5ac-fe624a77b42f/%E6%88%AA%E5%B1%8F2024-12-23_00.32.23.png" alt="截屏2024-12-23 00.32.23.png"></p><h3 id="1214-工料合同tm合同"><a class="markdownIt-Anchor" href="#1214-工料合同tm合同">#</a> 12.1.4 工料合同 (T&amp;M 合同)</h3><ul><li>成本补偿合同和总价合同特点的混合型合同</li><li>必须为每一个单位的工作量付出一定的报酬</li></ul><h3 id="1215-敏捷合同"><a class="markdownIt-Anchor" href="#1215-敏捷合同">#</a> 12.1.5 敏捷合同</h3><ul><li>多层协议结构</li><li>价值交付 (例如迭代付费)：</li></ul><p>强调价值交付，基于价值驱动进行迭代交付</p><ul><li>总价增量 (例如基于 Story 付费)：</li></ul><p>不限定项目总预算，将范围分解为一些微型交付成果</p><ul><li>灵活总价方案</li><li>动态范围方案</li></ul><h2 id="122-习题"><a class="markdownIt-Anchor" href="#122-习题">#</a> 12.2 习题</h2><ol><li>预计成本 = 10 万，固定费用 = 1.5 万，实际成本 = 30 万，支付总价：31.5 万</li><li>敏捷宣言哪句话可以体现敏捷合同特性：客户合作高于合同谈判</li><li>某项目采用成本加激励费用的成本补偿类合同，当预计成本为 20 万元，利润 4 万元，且奖励分配为 80/20 时，如果实际成本降至 16 万，则项目总价为：20.8 万元</li><li>对于乙方来说，成本补偿类合同的风险大于固定价格合同的风险，甲方则相反 ❌</li><li>如果一个项目的合同类型是固定价格（FFP），合同价格是 100 万元，实际花费 160 万元，则项目结算金额为 160 万 ❌</li><li>成本加激励费用（CPIF）合同具有激励机制 ✅</li><li>《敏捷宣言》认为 “客户协作高于合同协商” ✅</li></ol><h1 id="十三-集成计划执行控制-30"><a class="markdownIt-Anchor" href="#十三-集成计划执行控制-30">#</a> 十三、集成计划执行控制 - - - - - - - - - - - - - - - - - - - - - - - 30</h1><h2 id="131-相关定义"><a class="markdownIt-Anchor" href="#131-相关定义">#</a> 13.1 相关定义</h2><h3 id="1311-项目集成管理"><a class="markdownIt-Anchor" href="#1311-项目集成管理">#</a> 13.1.1 项目集成管理</h3><ul><li>项目集成管理由项目经理负责</li><li>包括：范围、进度、成本、质量、人力、沟通、干系人、风险、变更计划</li></ul><h3 id="1312-软件项目管理的四个重要要素"><a class="markdownIt-Anchor" href="#1312-软件项目管理的四个重要要素">#</a> 13.1.2 软件项目管理的四个重要要素</h3><ul><li>范围 (S)</li><li>质量 (Q)</li><li>进度 (T)</li><li>成本 ©</li><li>关系：C = F (S，Q，T)</li></ul><ol><li>C 与 S 成一定的正比关系</li><li>C 与 Q 成一定的反比关系</li><li>C 与 T 成一定的反比关系</li></ol><h3 id="1313-项目执行控制的步骤"><a class="markdownIt-Anchor" href="#1313-项目执行控制的步骤">#</a> 13.1.3 项目执行控制的步骤</h3><p>建立标准 → 采集项目实际数据 → 实际结果与计划比较 → 决定是否修正计划 → 修正计划，协调各方</p><h3 id="1314-项目数据"><a class="markdownIt-Anchor" href="#1314-项目数据">#</a> 13.1.4 项目数据</h3><ul><li>是项目执行控制的依据</li><li>包括：范围、时间、成本、质量、团队、沟通、干系人、风险、合同管理</li></ul><h3 id="1315-快速决策比追求绝对正确更重要"><a class="markdownIt-Anchor" href="#1315-快速决策比追求绝对正确更重要">#</a> 13.1.5 快速决策比追求绝对正确更重要</h3><h3 id="1316-项目集成管理的核心要素以价值交付为中心"><a class="markdownIt-Anchor" href="#1316-项目集成管理的核心要素以价值交付为中心">#</a> 13.1.6 项目集成管理的核心要素 (以价值交付为中心)</h3><ul><li>传统三角：范围 - 成本 - 时间</li><li>敏捷三角：价值 - 约束 - 质量</li></ul><h1 id="十四-核心计划执行控制-31"><a class="markdownIt-Anchor" href="#十四-核心计划执行控制-31">#</a> 十四、核心计划执行控制 - - - - - - - - - - - - - - - - - - - - - - - 31</h1><h2 id="141-相关定义"><a class="markdownIt-Anchor" href="#141-相关定义">#</a> 14.1 相关定义</h2><h3 id="1411-范围管理"><a class="markdownIt-Anchor" href="#1411-范围管理">#</a> 14.1.1 范围管理</h3><ul><li>范围执行控制是基于 WBS 监督项目的范围状态，管理范围基准变更的过程</li><li>分析技术：</li></ul><ol><li>偏差分析</li><li>趋势分析</li></ol><ul><li>范围控制要点：</li></ul><ol><li>防止不合理的范围扩张 (蔓延、镀金)</li></ol><h3 id="1412-成本-时间管理"><a class="markdownIt-Anchor" href="#1412-成本-时间管理">#</a> 14.1.2 成本、时间管理</h3><ul><li>图解控制法</li><li>挣值分析法</li><li>网络图分析</li></ul><h3 id="1413-图解控制法"><a class="markdownIt-Anchor" href="#1413-图解控制法">#</a> 14.1.3 图解控制法</h3><ul><li>进度图、成本图、资源图</li><li>偏差分析与控制：</li></ul><ol><li><p>精确记录任务消耗的实际时间</p></li><li><p>量化任务的计划偏差：</p><p>持续时间偏差 (%) = ((实际持续时间 - 计划持续时间)/ 计划持续时间) * 100</p><p>进度偏差 (%) = ((实际结束时间 - 计划结束时间)/ 计划持续时间) * 100</p></li><li><p>对计划偏差进行根因分析</p></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/c12deeb3-a9f8-4abc-beb7-8565eb4356de/%E6%88%AA%E5%B1%8F2024-12-23_02.37.46.png" alt="截屏2024-12-23 02.37.46.png"></p><h3 id="1414-挣值分析法"><a class="markdownIt-Anchor" href="#1414-挣值分析法">#</a> 14.1.4 挣值分析法</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/34b4af80-e43a-4de6-9752-08e73dd6a4ef/%E6%88%AA%E5%B1%8F2024-12-23_02.45.52.png" alt="截屏2024-12-23 02.45.52.png"></p><ul><li>输入：</li></ul><ol><li>BAC (预算总值 (估算结果))</li><li>TAC (预计完成时间)</li><li>BCWS (计划工作成本)</li><li>ACWP (实际工作成本)</li><li>BCWP (已获值 (已完成工作的预算成本))</li></ol><ul><li>输出：CV，CPI，SV，SPI，EAC，SAC，VAC，VAT，TCPI</li></ul><ol><li>进度差异：SV = BCWP - BCWS (=0：按照计划进度进行，&lt;0：落后于进度，&gt;0：超前于进度)</li><li>成本差异：CV = BCWP - ACWP (=0：按照计划预算进行，&lt;0：比预算差，&gt;0：比预算好)</li><li>进度效能指标：SPI = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi></mrow><mrow><mi>B</mi><mi>C</mi><mi>W</mi><mi>S</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{BCWP}{BCWS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>(=1：按照计划进度进行，&lt;1：落后于进度，&gt;1：超前于进度)</li><li>成本效能指标：CPI = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi></mrow><mrow><mi>A</mi><mi>C</mi><mi>W</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{BCWP}{ACWP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>(=1：按照计划预算进行，&lt;1：超出预算，&gt;1：低于预算)</li><li>预测项目完成成本：EAC = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>B</mi><mi>A</mi><mi>C</mi></mrow><mrow><mi>C</mi><mi>P</mi><mi>I</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{BAC}{CPI}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">CP</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>预测项目完成时间：SAC = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>T</mi><mi>A</mi><mi>C</mi></mrow><mrow><mi>S</mi><mi>P</mi><mi>I</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{TAC}{SPI}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">SP</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>成本偏差：VAC = BAC - EAC</li><li>时间偏差：VAT = TAC - SAC</li><li>未完工指数：TCPI = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mtext>剩余工作</mtext><mtext>剩余成本</mtext></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>B</mi><mi>A</mi><mi>C</mi><mo>−</mo><mi>B</mi><mi>C</mi><mi>W</mi><mi>P</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>G</mi><mi>o</mi><mi>a</mi><mi>l</mi><mo>−</mo><mi>A</mi><mi>C</mi><mi>W</mi><mi>P</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{剩余工作}{剩余成本} = \frac{(BAC - BCWP)}{(Goal - ACWP)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">剩余成本</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">剩余工作</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">G</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">BC</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">W</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ol><h3 id="1415-bcwp的计算"><a class="markdownIt-Anchor" href="#1415-bcwp的计算">#</a> 14.1.5 BCWP 的计算</h3><ul><li>50/50 规则：当一项任务开始、没有结束前，获得一半的价值</li><li>0/100 规则：当一项任务没有完成前，没有价值</li><li>经验加权：按照经验百分比计算价值</li></ul><h3 id="1416-cpi性能指标"><a class="markdownIt-Anchor" href="#1416-cpi性能指标">#</a> 14.1.6 CPI (性能指标)</h3><p>进度进展到 20% 左右时，CPI 趋于稳定</p><h3 id="1417-网络图分析了解"><a class="markdownIt-Anchor" href="#1417-网络图分析了解">#</a> 14.1.7 网络图分析 (了解)</h3><p>待补充</p><h3 id="1418-质量执行控制"><a class="markdownIt-Anchor" href="#1418-质量执行控制">#</a> 14.1.8 质量执行控制</h3><ul><li>QC：技术评审 → 代码评审 / 走查 → 软件测试 → 返工</li></ul><ol><li>技术评审：召开评审会议</li><li>代码评审 / 走查：由一组人通过阅读、讨论和争议对程序进行静态分析的过程 / 在代码编写阶段，开发人员自己检查自己的代码。</li></ol><h3 id="1419-qc手段"><a class="markdownIt-Anchor" href="#1419-qc手段">#</a> 14.1.9 QC 手段：</h3><ul><li>控制图法：</li></ul><ol><li>显示软件产品的质量随着时间变化的情况，在图中标识出质量控制的偏差标准</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/1fb3beb0-59d8-4e95-8361-56b11c8c474f/%E6%88%AA%E5%B1%8F2024-12-23_03.09.12.png" alt="截屏2024-12-23 03.09.12.png"></p><ul><li>趋势分析：</li></ul><p>运用数字技巧，依据过去的成果预测将来的产品</p><ul><li>抽样统计</li></ul><h3 id="14110-敏捷核心理念价值驱动的需求可调"><a class="markdownIt-Anchor" href="#14110-敏捷核心理念价值驱动的需求可调">#</a> 14.1.10 敏捷核心理念：价值驱动的需求可调</h3><h3 id="14111-敏捷项目范围管理"><a class="markdownIt-Anchor" href="#14111-敏捷项目范围管理">#</a> 14.1.11 敏捷项目范围管理</h3><ul><li>把需求列入未完项</li><li>不断构建和评审圆形系统</li><li>通过发布多个版本来明确需求</li></ul><h3 id="14112-敏捷项目进展衡量的原则"><a class="markdownIt-Anchor" href="#14112-敏捷项目进展衡量的原则">#</a> 14.1.12 敏捷项目进展衡量的原则</h3><ul><li>交付价值替代预测型衡量指标</li><li>在软件开发中，价值流的直接体现是从想法和假设到软件功能上线并产生客户价值的过程。</li></ul><h3 id="14113-基于迭代的项目指标迭代速率"><a class="markdownIt-Anchor" href="#14113-基于迭代的项目指标迭代速率">#</a> 14.1.13 基于迭代的项目指标：迭代速率</h3><p>迭代速率：反映了一个团队在一个迭代周期内所能交付的 Story 个数</p><h3 id="14114-基于流程的衡量指标"><a class="markdownIt-Anchor" href="#14114-基于流程的衡量指标">#</a> 14.1.14 基于流程的衡量指标</h3><ul><li>交付周期：交付一个工作项目花费的总时间，从项目添加到看板直至项目完成</li><li>周期时间：处理一个工作项目所需的时间</li><li>响应时间：一个工作项目等待工作开始的时间</li></ul><h3 id="14115-控制在制品wip"><a class="markdownIt-Anchor" href="#14115-控制在制品wip">#</a> 14.1.15 控制在制品 (WIP)</h3><h3 id="14116-燃尽图-燃起图-甘特图"><a class="markdownIt-Anchor" href="#14116-燃尽图-燃起图-甘特图">#</a> 14.1.16 燃尽图、燃起图、甘特图</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/8e2822fe-1222-4850-b3df-dd8e4d9d1d80/%E6%88%AA%E5%B1%8F2024-12-23_03.19.31.png" alt="截屏2024-12-23 03.19.31.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/6f0d32d9-283a-4422-ba9a-63d4ea276b13/%E6%88%AA%E5%B1%8F2024-12-23_03.19.42.png" alt="截屏2024-12-23 03.19.42.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/9a27b221-0b33-450e-99eb-5d42744bb2dc/07e83479-19a1-48d8-95bd-f56899e185bd/%E6%88%AA%E5%B1%8F2024-12-23_03.23.24.png" alt="截屏2024-12-23 03.23.24.png"></p><h3 id="14117-devops快速交付"><a class="markdownIt-Anchor" href="#14117-devops快速交付">#</a> 14.1.17 Devops 快速交付</h3><h2 id="142-习题"><a class="markdownIt-Anchor" href="#142-习题">#</a> 14.2 习题</h2><ol><li>范围控制的一个重点是避免需求的不合理扩张 ✅</li><li>一个任务原计划 2 个人全职工作 2 周完成。而实际上只有一个人参与这个任务，到第二周末，这个人完成了任务的 75%。则：BCWS=? 人周，ACWP=? 人周，BCWP=? 人周：4 2 3</li><li>一个任务原计划 2 个人全职工作 2 周完成。而实际上只有一个人参与这个任务，到第二周末，这个人完成了任务的 75%。则：CV=？SV=？：CV=1 SV=-1</li><li>一个任务原计划 2 个人全职工作 2 周完成。而实际上只有一个人参与这个任务，到第二周末，这个人完成了任务的 75%。则：CPI = ？：1.5</li><li>TCPI = 2.17 含义：投入 1 元将来需要产生 2.17 元的价值</li><li>当进度进展到（）左右时，CPI 处于稳定：20%</li><li>下面哪项活动是质量保证 (QA) 活动：过程审计</li><li>下面哪项活动是质量控制 (QC) 活动：软件测试</li><li>如果成本效能指标 CPI=90%，它说明什么：投入 1 元产生 0.90 元的效果</li><li>进度控制重要的一个组成部分是下面哪项：确定进度偏差是否需要采取纠正措施</li><li>关于抽样统计的方法的描述，下面哪项是正确的：以小批量的抽样为基准进行检验</li><li>项目进度成本控制的基本目标是在给定的限制条件下，用最短时间、最小成本，以最小风险完成项目工作 ✅</li><li>在使用应急法压缩进度时，不一定要在关键路径上选择活动来进行压缩 ❌</li><li>累计费用曲线中某时间点 ACWP 比 BCWS 高，意味着在这个时间点为止，实际的成本要比计划的高 ✅</li><li>技术评审的目的是尽早发现工作成果中的缺陷，并帮助开发人员及时消除缺陷，从而有效地提高产品的质量 ✅</li></ol><h1 id="十五-辅助计划执行控制-35"><a class="markdownIt-Anchor" href="#十五-辅助计划执行控制-35">#</a> 十五、辅助计划执行控制 - - - - - - - - - - - - - - - - - - - - - - - 35</h1><h2 id="151-相关定义"><a class="markdownIt-Anchor" href="#151-相关定义">#</a> 15.1 相关定义</h2><h3 id="151-团队计划执行控制"><a class="markdownIt-Anchor" href="#151-团队计划执行控制">#</a> 15.1 团队计划执行控制</h3><ul><li>团队建设 → 项目培训 → 人员激励</li><li>项目培训特点：短期，片段式，针对性强，见效快</li><li>激励理论：马斯洛的需求层次理论，海兹伯格的激励理论，麦克勒格的 X - 理论和 Y - 理论，超 Y 理论，Z 理论，期望理论</li></ul><h3 id="1512-干系人计划执行控制"><a class="markdownIt-Anchor" href="#1512-干系人计划执行控制">#</a> 15.1.2 干系人计划执行控制</h3><table><thead><tr><th>干系人</th><th>联系方式</th><th>角色</th><th>目前参与程度</th><th>需要的参与程度</th><th>规划</th><th>状态</th></tr></thead><tbody><tr><td>支持</td><td colspan="2">定期拜访</td></tr></tbody></table><h3 id="1513-沟通计划执行"><a class="markdownIt-Anchor" href="#1513-沟通计划执行">#</a> 15.1.3 沟通计划执行</h3><ul><li>书面沟通和口头沟通</li><li>语言沟通和非语言沟通</li><li>正式沟通和非正式沟通</li><li>单向沟通和双向沟通</li><li>网络沟通</li><li>沟通技术：</li></ul><ol><li>利用信息技术</li><li>项目会议 (定期会议，事件会议，阶段会议)</li><li>非正式方式 (结对编程，讨论，聊天，聚会)</li></ol><h3 id="1514-风险控制过程"><a class="markdownIt-Anchor" href="#1514-风险控制过程">#</a> 15.1.4 风险控制过程</h3><p>任命风险管理负责人 → 实施和跟踪风险管理计划 → 确保针对风险策略正在合理使用 → 监视剩余的风险和识别新的风险</p><h3 id="1515-合同管理"><a class="markdownIt-Anchor" href="#1515-合同管理">#</a> 15.1.5 合同管理</h3><ul><li>甲方合同管理：</li></ul><ol><li>对采购对象的检验和验收过程</li><li>违约事件处理过程</li></ol><ul><li>乙方合同管理：</li></ul><ol><li>合同执行跟踪管理过程</li><li>合同修改控制</li><li>违约事件处理过程</li><li>产品维护过程</li></ol><h2 id="152-习题"><a class="markdownIt-Anchor" href="#152-习题">#</a> 15.2 习题</h2><ol><li>麦克勒格的 Y - 理论是一种强制管理理论 ❌</li><li>项目中的重要成员要同时离开公司，项目经理首先应该：实施风险计划</li><li>对于项目冲突而言，下面哪个说法是正确的：冲突不一定是坏事情，常常是有利的事情</li><li>“为什么大家不能都让一步解决这个问题呢？”，这是哪类冲突解决方法的体现：妥协</li><li>麦克勒格的 X 理论是参与理论 ❌</li><li>敏捷生存期模型中的每天站立会议是很有效的一种沟通方式 ✅</li></ol><h1 id="十六-项目结束-36"><a class="markdownIt-Anchor" href="#十六-项目结束-36">#</a> 十六、项目结束 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 36</h1><h2 id="161-相关定义"><a class="markdownIt-Anchor" href="#161-相关定义">#</a> 16.1 相关定义</h2><h3 id="1611-传统项目管理基于计划的预测过程"><a class="markdownIt-Anchor" href="#1611-传统项目管理基于计划的预测过程">#</a> 16.1.1 传统项目管理：基于计划的预测过程</h3><h3 id="1612-敏捷项目管理基于价值的自适应过程"><a class="markdownIt-Anchor" href="#1612-敏捷项目管理基于价值的自适应过程">#</a> 16.1.2 敏捷项目管理：基于价值的自适应过程</h3><h3 id="1613-项目结束过程"><a class="markdownIt-Anchor" href="#1613-项目结束过程">#</a> 16.1.3 项目结束过程</h3><ul><li>项目验收 → 合同终止 → 项目最后评审 → 项目总结报告</li><li>项目最后评审：</li></ul><ol><li>是否实现项目目标</li><li>是否遵循项目进度</li><li>是否在预算成本内完成项目</li><li>项目进度过程中出现问题以及解决措施是否合适</li><li>从该项目的实践中可以得到哪些经验和教训</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组织与结构笔记</title>
    <link href="/ilcyl/ilcyl.github.io.git/2023/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    <url>/ilcyl/ilcyl.github.io.git/2023/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组织与结构">计算机组织与结构</h1><h1 id="第一章"><strong><em>第一章</em></strong></h1><h2 id="基本概念"><font color=Red>基本概念:</font></h2><h3id="体系架构architecture"><font color=Red>(*)</font>体系架构(Architecture):</h3><h4id="程序员可以看到的属性包括指令集用于数据表示的位数io机制寻址技术等"><font color="#0099ff">程序员可以看到的属性，包括指令集，用于数据表示的位数、I/O机制、寻址技术等</font></h4><h3 id="组织organization">组织(Organization):</h3><h4id="架构是怎么实现的例如通过什么控制信号来实现控制采用什么接口用什么内存技术"><font color="#0099ff">架构是怎么实现的，例如通过什么控制信号来实现控制，采用什么接口，用什么内存技术</font></h4><h3 id="结构structure">结构(Structure):</h3><h4id="计算机各个组件之间相互关联的方式"><font color="#0099ff">计算机各个组件之间相互关联的方式</font></h4><h3 id="功能function"><font color=Red>(*)</font>功能(Function):</h3><h4id="组成计算机的组件可以进行的操作"><font color="#0099ff">组成计算机的组件可以进行的操作</font></h4><h2 id="重点知识点"><font color=Red>重点知识点:</font></h2><h3id="计算机的主要部件"><font color=Red>(*)</font>计算机的主要部件:</h3><h4id="处理器cpu内存磁盘控制器和磁盘输入输出设备键盘显示器图形适配器内部cache连接各个部件的总线其他部件"><font color="#0099ff">处理器CPU，内存，磁盘控制器和磁盘，输入输出设备(键盘，显示器，图形适配器)，内部Cache，连接各个部件的总线，其他部件</font></h4><h3 id="指令的简单执行过程">指令的简单执行过程:</h3><div class="note note-info">            <p><font color=Red>Add &amp;nbsp R1, R2</font><br><font color=skyBlue>a. &amp;nbsp ALU1 ← [R1] </font><br> {content of R1is moved to ALU1 } <em>(R1的内容移动到ALU1)</em> <br><font color=skyBlue>b. &amp;nbsp ALU2 ← [R2] </font><br> {content of R2is moved to ALU2 } <em>(R2的内容移动到ALU2)</em> <br><font color=skyBlue>c. &amp;nbsp ADD </font><br> {content of ALU1 + ALU2= ALU3 }<br> <font color=skyBlue>d. &amp;nbsp R1 ← [ALU3] </font><br>{Result of addition is moved to R1}<br></p>          </div><h3 id="组织架构在体系中的位置">组织架构在体系中的位置:</h3><p><img src="/image/res/1.png" /> <div class="note note-secondary">            <ul><li>翻译： Layers of computer functions or subsystems <br>计算机功能或子系统的层 <br> Application Program; Complier; OS <br>应用程序； 编译程序； 操作系统 <br> COA: 计算机组织与体系结构 <br>Circuit Design; Chip Layout <br> 电路设计； 芯片规划</li></ul>          </div> <div class="note note-danger">            <ul><li>补充：计算机组织架构是计算机硬件与软件之间的接口和互动方式，包括以下几个方面：<br>1.指令集架构 <br> 2.存储器层次结构 <br> 3.总线结构 <br></li></ul>          </div></p><h2 id="补充"><font color=Red>补充:</font></h2><h3id="计算机由门和存储单元以及连接组成"><font color=Red>(*)</font>计算机由门和存储单元以及连接组成</h3><h3id="嵌入式系统是计算机硬件和软件的组合或者额外的机械或其他部件设计执行专用功能"><font color=Red>(*)</font>嵌入式系统是计算机硬件和软件的组合，或者额外的机械或其他部件，设计执行专用功能</h3><blockquote><p>is a combination of computer hardware and software, and perhapsadditional mechanical or other parts,designed to perform a dedicatedfunction</p></blockquote><h3id="重新排序以下项目以说明内存层次结构最接近cpu的项目应该放在第一个最远的最后一个它们是寄存器cache主内存磁盘cdromtape磁带"><font color=Red>(*)</font>重新排序以下项目，以说明内存层次结构。最接近CPU的项目应该放在第一个，最远的最后一个。它们是寄存器，Cache，主内存，磁盘，CDROM，Tape(磁带)</h3><blockquote><p>Reorder the following items to illustrate the memory hierarchy.Theitem that is closest to CPU should be put to the first, thefarthest thelast. They are Registers, Cache, Main Memory,Hard Disk, CDROM,Tape</p></blockquote><h1 id="第二章"><strong><em>第二章</em></strong></h1><h2 id="基本概念-1"><font color=Red>基本概念:</font></h2><h3id="冯诺依曼机存储程序计算机"><font color=Red>(*)</font>冯诺依曼机(存储程序计算机):</h3><h4id="有一个主存储器主存储器内可以存储数据和指令-2.-数据和指令都以二进制的方式存储在主存储器中-3.-数据和指令通过地址来进行寻址-4.-数字逻辑单元alu执行基本的操作-5.-由控制单元cu来确定合适的操作顺序"><font color="#0099ff">1.有一个主存储器，主存储器内可以存储数据和指令；<br>2.数据和指令都以二进制的方式存储在主存储器中；<br>3.数据和指令通过地址来进行寻址；<br>4.数字逻辑单元ALU执行基本的操作；<br>5.由控制单元CU来确定合适的操作顺序。</font></h4><h3 id="系列机"><font color=Red>(*)</font>系列机:</h3><h4id="具有相同或几乎相同的指令集-2.-相同或相似的操作系统-3.-随着技术的提高计算机的速度逐步提升-4.-计算机的io端口的数量逐步提升-5.-计算机的主存容量的逐步增加-6.-计算机的成本也随之增加"><font color="#0099ff">1.具有相同或几乎相同的指令集；<br>2. 相同或相似的操作系统；<br>3.随着技术的提高，计算机的速度逐步提升；<br>4.计算机的I/O端口的数量逐步提升；<br>5. 计算机的主存容量的逐步增加；<br>6.计算机的成本也随之增加。</font></h4><h3 id="摩尔定律">摩尔定律:</h3><h4id="晶体管数量每年翻一倍"><font color="#0099ff">晶体管数量每年翻一倍</font></h4><blockquote><p><font color=Red>意义:</font> <br> *芯片的成本几乎没有变化：<strong>计算机的成本下降了</strong> <br> *更高的封装密度意味着<strong>更短的电子路径</strong>，提供更高的速度 <br>* <strong>体积更小</strong>，便于放置在各种环境中 <br> *<strong>降低了电源和冷却要求</strong> <br> * 更少的互连增加了可靠性</p></blockquote><h3 id="平衡思想">平衡思想:</h3><h4id="各个组成部件之间找到一个最佳的组合方案在处理器主存io设备以及互连结构的吞吐量和处理要求之间进行平衡-2.-计算机架构设计中不断进行设计的更新以达到处理器内存io设备以及互连结构之间的平衡以实现最大的整体性能"><font color="#0099ff">1.各个组成部件之间找到一个最佳的组合方案，在处理器、主存、IO设备以及互连结构的吞吐量和处理要求之间进行平衡；<br>2.计算机架构设计中，不断进行设计的更新，以达到处理器、内存、I/O设备以及互连结构之间的平衡，以实现最大的整体性能</font></h4><h2 id="重点知识点-1"><font color=Red>重点知识点:</font></h2><h3id="计算机的发展代次"><font color=Red>(*)</font>计算机的发展代次:</h3><ul><li>第一代：真空管</li><li>第二代：晶体管</li><li>第三代：集成电路</li><li><font color=Red>根据使用的电子元器件划分计算机时代</font></li></ul><h3 id="性能评估方法cpi"><font color=Red>(*)</font>性能评估方法CPI:</h3><p><img src="/image/res/CPI.png" /> 例：<br>在400MHZ处理器上执行200万条指令</p><table><thead><tr class="header"><th>指令类型</th><th>CPI</th><th>指令占比</th></tr></thead><tbody><tr class="odd"><td>算术和逻辑运算</td><td>1</td><td>60%</td></tr><tr class="even"><td>Cache命中的取数/存数</td><td>2</td><td>18%</td></tr><tr class="odd"><td>分支</td><td>3</td><td>12%</td></tr><tr class="even"><td>Cache失效的存储器访问</td><td>12</td><td>10%</td></tr></tbody></table><p><div class="note note-danger">            <p><span class="math display">\[CPI = 0.6 + 2 ∗ 0.18 + 4 ∗ 0.12 + 12 ∗ 0.1 = 2.64\]</span> <span class="math display">\[MIPS = \frac{f}{CPI*10^6}= \frac{400}{2.64} = 152\]</span> 计算加速比： <span class="math display">\[T = \frac{I_c(指令数)}{MIPS * 10^6}\]</span>对于8个处理器，有额外的开销。每个处理器执行200万条指令中的1/8加上25000条开销指令。在这种情况下，8个处理器中的每个处理器的执行时间为：<span class="math display">\[T_s = \frac{2 * 10^6/8 + 25000}{152 * 10^6} = 1.8 ms\]</span> 对于单处理器情况是: <span class="math display">\[T_1 = \frac{2 ∗ 10^6} {178 ∗ 10^6} =11.24ms\]</span> <span class="math display">\[Speedup(加速比) = \frac{time \ to \ excute  \ program \ on \ a \ single\  processor} {time \ to \ excute \ on \ N \ parallel \ processors} =\frac{11.24}{1.8} = 6.24\]</span></p>          </div></p><h3 id="阿姆达定律">阿姆达定律:</h3><h5id="假定一段代码中有f部分是可以无限制地进行并行并且没有调度产生的代价1-f部分是必须串行运行的如果这个程序在单处理器上的执行时间是t那么如果我们使用n个处理器来运行这个程序运行速度的比例也就是加速比可以用下面的公式来计算">假定一段代码中，有f部分是可以无限制地进行并行，并且没有调度产生的代价；1-f部分是必须串行运行的。如果这个程序在单处理器上的执行时间是T，那么，如果我们使用N个处理器来运行这个程序，运行速度的比例，也就是加速比可以用下面的公式来计算：</h5><p><span class="math display">\[Speedup = \frac{T(1-f) + Tf}{T(1-f) + \frac{Tf}{N}} = \frac{1}{(1-f) +\frac{f}{N}}\]</span></p><h3 id="基准测试的评估计算">基准测试的评估计算:</h3><h4id="算数平均计算平均执行速度"><font color="#0099ff">算数平均：计算平均执行速度</font></h4><p><img src="/image/res/RA.png" /></p><h4id="调和平均指令的平均执行时间"><font color="#0099ff">调和平均：指令的平均执行时间</font></h4><p><img src="/image/res/RB.png" /></p><h1 id="第三章"><strong><em>第三章</em></strong></h1><h2 id="基本概念-2"><font color=Red>基本概念:</font></h2><ul><li><p>PC：Program counter 程序计数器</p></li><li><p>IR ：Instruction register 指令寄存器</p></li><li><p><font color=Red>(*)</font>MAR ：Memory address register存储器地址寄存器</p></li><li><p>MBR ：Memory buffer register 存储器缓冲寄存器</p></li><li><p>I/O AR ： I/O address register IO地址寄存器</p></li><li><p>I/O BR ： I/O buffer register IO缓冲寄存器</p></li><li><p>AC：Accumulator 累加器</p></li><li><p>ALU：Arithmetic and Logic Unit 算术逻辑单元</p></li><li><p>CU：Control Unit 控制单元</p></li><li><p>指令周期： <div class="note note-warning">            <p><font color=Red>(*)</font><font color=Red>指令的执行分为两个阶段：取指(Fetchcycle) - 执行(Execute cycle)</font> <br>一个指令最基本的处理过程称为指令周期 <br> <img src="/image/res/2.png" /><br> 取指周期: <br>   计算机进行指令的读取 <br> 执行周期: <br>  计算机执行这个指令。然后继续读取下一条指令 <br><font color=Red>中断周期:</font> <br>   进行中断的处理 <br><font color=Red>间接周期:</font> <br>   间接寻址</p>          </div></p></li><li><p><font color=Red>(*)</font>中断:</p></li><li><p><img src="/image/res/45.png" /> <div class="note note-light">            <p><font color=Red>指令的执行过程，带中断的执行过程</font> <br><font color=Red>中断是其他模块打断正常执行顺序的一种机制</font> <br><font color=Red>目的:</font> <br> 减少CPU的等待时间，提高CPU的效率</p>          </div></p></li><li><p>互联结构: <div class="note note-light">            <p>计算机包括CPU、内存和I/O <br> 所有的单元都需要连接以完成指令 <br><font color=Red>将计算机中的各个模块连接在一起的通道称为互联结构</font></p>          </div></p></li><li><p>总线: <div class="note note-success">            <p>连接2个或多个设备的通信通路 <br>一个总线有多个通道(比如32位总线有32个独立的位通道) <br><font color=skyBlue>电源线不算总线</font> <br><font color=Red>分类:</font> <br><br />  数据总线，地址总线和控制总线</p>          </div></p></li><li><p>总线仲裁: <br>  <font color=Red>每个时间段只能有一个设备进行数据的发送</font></p></li><li><p>总线宽度: <br>  <font color=Red>一般采用组的方式，将多条线放在一起，形成一组总线，同时可以传送多位。一组总线中传输线的数量</font></p></li><li><p>总线速度: <br>  <font color=Red>1秒钟通过每根导线能传多少个bit</font></p></li><li><p>总线带宽: <br>  <font color=Red>也叫吞吐量，总线传输速率，指的是通过总线1秒钟能传输的总数据量</font></p></li></ul><h2 id="重点知识点-2"><font color=Red>重点知识点:</font></h2><h3 id="中断处理方式">中断处理方式:</h3><p><img src="/image/res/3.png" /></p><h3 id="多重中断的处理">多重中断的处理:</h3><h4 id="顺序处理中断">顺序处理中断:</h4><div class="note note-primary">            <p>先处理中断x再处理中断y(中断x在y前) <br><font color=Red>高优先级的中断无法及时处理</font></p>          </div><h4 id="中断嵌套">中断嵌套:</h4><div class="note note-primary">            <p>允许中断被打断 <br> 定义优先级 <br><font color=Red>低级别中断能够被高级别中断所中断<br>高级别中断完成后，继续处理之前的中断</font></p>          </div><h3 id="总线类型"><font color=Red>(*)</font>总线类型:</h3><h4 id="系统总线">系统总线:</h4><p>  连接计算机主要部件的总线称为系统总线</p><h4 id="数据总线">数据总线:</h4><div class="note note-warning">            <p>提供模块之间传输数据的通道 <br><font color=Red>(*)</font>总线中的数据线越多，那么同时传送的数据就越多</p>          </div><h4 id="地址总线"><font color=Red>(*)</font>地址总线:</h4><div class="note note-warning">            <p>用于确定数据在存储器中的位置 <br><font color=Red>(*)</font>地址线越多，能够寻址的存储器的空间也越大</p>          </div><h4 id="控制总线">控制总线:</h4><div class="note note-warning">            <p>用于发送控制信号 <br><font color=Red>(*)</font>控制总线中控制线越多，能发出的控制信号也能越复杂<br></p>          </div><h3 id="总线的使用方式"><font color=Red>总线的使用方式:</font></h3><h4id="假定一个模块需要发送数据给另一个模块它需要这样去做"><font color="#0099ff">假定一个模块需要发送数据给另一个模块，它需要这样去做：</font></h4><blockquote><ol type="1"><li>获取总线的使用权；</li><li>获得总线的使用权之后，再通过总线发送数据。</li></ol></blockquote><h4id="假定一个模块需要向另一个模块请求数据它需要这样去做"><font color="#0099ff">假定一个模块需要向另一个模块请求数据，它需要这样去做：</font></h4><blockquote><ol type="1"><li>获取总线的使用权；</li><li>通过控制和地址总线向那个模块发送数据请求；</li><li>等待那个模块发送数据过来</li></ol></blockquote><h3 id="总线结构">总线结构:</h3><h4 id="单总线结构">单总线结构:</h4><blockquote><p>多个单元通过一组线连在一起数据传输达到总线容量限制后，总线会成为瓶颈</p></blockquote><h4 id="多总线结构">多总线结构:</h4><blockquote><p>多个总线分层设置 靠近CPU的是高速总线 远离CPU的是低速总线</p></blockquote><h4 id="传统的总线结构">传统的总线结构:</h4><p><img src="/image/res/4.png" /></p><h3 id="总线设计要素">总线设计要素</h3><h4 id="类型">类型：</h4><ul><li>专用总线：<br>   只负责某一方面的工作，和其他工作不冲突</li><li>共享总线: <br>   多种功能都用同一个总线 <br>   线少 <br>  控制复杂，性能受限</li></ul><h4 id="仲裁方式"><font color="#0099ff">仲裁方式：</font></h4><ul><li><font color=Red>主从机制：主节点控制总线，将信息放在总线上，从节点从主节点接收信息</font></li><li>集中式：单个硬件设备控制总线访问，称为总线控制器或仲裁器<div class="note note-info">            <ul><li><font color=Red>链式询问方式</font> <br></li><li>三个控制线：<br>     BS: bus busy 总线忙 <br>     BR: bus request总线请求 <br>     BG: bus grant 总线允许 <br></li><li>每个设备发BR信号 <br></li><li><font color="#0099ff">BG从高优先级到低优先级通过各个模块</font><br></li><li><font color="#0099ff">最靠近仲裁器的是最高优先级</font> <br> <imgsrc="/image/res/5.png" /></li></ul>          </div> <div class="note note-info">            <ul><li><font color=Red>计数器定时询问方式</font> <br></li><li>三个控制线：BS，BR，BG <br><font color=Red>用计数器发送轮询信号(代替BG)</font> <br></li><li>过程：<br>     设备发出BR <br>    收到BR后，如果BS=0，仲裁器发出设备地址信号 <br>    如果地址到达发出BR的设备，设备就可以使用总线 <br>     计数器停止轮询<br></li><li><font color="#0099ff">优先级由仲裁器决定</font> <br></li></ul>          </div> <div class="note note-info">            <ul><li><font color=Red>独立请求方式</font></li><li>每个设备都有BR和BG</li><li>需要总线的设备发出BR信号</li><li>仲裁器决定哪个设备可以使用，就发一个BG信号给这个设备 <imgsrc="/image/res/6.png" /> &gt;*<font color="#0099ff">一般操作过程</font></li></ul>          </div>总线请求：需要总线的设备发出请求 <br> 总线仲裁：决定谁用 <br>设备地址：主节点获得总线使用权，发送目标地址到地址总线 <br>数据传输：在主和从节点之间传输数据 <br>总线释放：主节点和从节点在下一个总线周期释放总线</li><li>分布式：没有中央控制器 &gt; 每个模块都可以申请总线 &gt;控制逻辑在每个模块上 #### <font color="#0099ff">时序：</font></li><li>作用：确定总线上协调时间的方式</li><li><font color=Red>(*)</font>同步时序：总线上事件的发生由一个同步时钟来决定<br> <font color=Red>(**)</font>同步读、同步写： <imgsrc="/image/res/7.png" /></li><li><font color=Red>(*)</font>异步时序：总线上事件的发生由该事件的上一个事件来决定<br> 异步读 <img src="/image/res/8.png" /> 异步写 <imgsrc="/image/res/9.png" /></li></ul><h4 id="宽度">宽度:</h4><blockquote><p><strong><em>数据总线的宽度决定系统性能：</em></strong>一次传输的数据位数越多，系统性能越高<strong><em>地址总线的宽度决定了系统的容量：</em></strong>寻址的空间越大，这也意味着信息存储的越多<strong><em>控制总线的宽度决定了操作的灵活性：</em></strong>控制总线越宽，控制信号类型越多，操作越灵活</p></blockquote><h4 id="带宽">带宽:</h4><blockquote><p>带宽=总线宽度 * 总线速度</p></blockquote><h1 id="第四章"><strong><em>第四章</em></strong></h1><h2 id="基本概念-3"><font color=Red>基本概念:</font></h2><h3 id="存储系统层次结构">存储系统层次结构:</h3><h4id="目的通过多层存储的方式来解决存储器的容量性能和价格的问题">目的：通过多层存储的方式，来解决存储器的容量、性能和价格的问题</h4><p><img src="/image/res/10.png" /></p><h4 id="cache"><font color="#0099ff">Cache</font></h4><ul><li><p>容量小；速度快；位于主存和CPU之间；可能是一个单独的模块，也可能就直接放在CPU芯片上；价格昂贵</p></li><li><p>Cache的行、存储器的块</p></li><li><p><img src="/image/res/11.png" /></p></li><li><p>命中率与失效率: <div class="note note-primary">            <ul><li>命中：CPU在cache中请求数据，cache将内容返回给CPU，这称为一次命中<br></li><li>失效：CPU请求的数据不在cache中，数据需要从内存中读取 <br></li><li>命中率：上一层的数据请求在本层中能够完成的比例 <br></li><li>失效率：在本层中无法完成的比例。失效率=1-命中率 <br></li><li>失效惩罚：替换cache块的时间+传送数据给处理器的时间 <br></li></ul>          </div></p></li><li><p><font color="#0099ff">映射算法</font> <div class="note note-primary">            <ul><li>内存中的块数M远大于cache的行数，内存中的块映射到cache中的特定行的算法<br></li><li><strong><em>类型</em></strong>: <br></li><li><font color=Red>(**)</font><font color=Red size="4">直接映射:</font><br></li><li>存储器中的每个块只能映射到cache中唯一的一行 <br></li><li><font color="#0099ff">地址包括两部分：</font>低w位确定块中的字，高s位确定内存中的块，高s位在cache行中分为行域r和标记域s-r<br></li><li><font color="#0099ff">地址结构：</font>24位地址，<em>2位字标识</em>，每块有4个字节，<em>22位块标识</em>，14位行或者块地址，8位标志<br></li></ul><table><thead><tr class="header"><th style="text-align: center;">Tag s-r</th><th style="text-align: center;">Line or Slot r</th><th style="text-align: center;">Word w</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">14</td><td style="text-align: center;">2</td></tr></tbody></table><ul><li><font color=Red size="5">小结:</font> <br><font color=Red>(**)</font> <spanclass="math display">\[内存地址长度=s+w位\]</span> <spanclass="math display">\[内存块大小=cache的行大小=2^w\]</span> <spanclass="math display">\[内存块的数量=2^s\]</span> <spanclass="math display">\[寻址单元数=2^{s+w}\]</span> <spanclass="math display">\[cache的行数=2^r\]</span> <spanclass="math display">\[标记位的长度=s-r位\]</span></li><li><font color=Red size="4">全相联映射:</font> <br></li><li>主存中的块可以映射到cache中的任意一行 <br></li><li><font color="#0099ff">内存地址分解为：</font>tag和块内的字地址<br></li><li>tag唯一确定内存中的一行，cache行的tag用来检查是否匹配 <br></li><li><font color="#0099ff">地址结构：</font>22个标记位，每个块有4个字节32bit的数据，最低的2位确定cache中的块数据中，哪个字是需要的数据<br></li></ul><table><thead><tr class="header"><th style="text-align: center;">Tag</th><th style="text-align: center;">Word</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">22 bit</td><td style="text-align: center;">2 bit</td></tr></tbody></table><ul><li><font color=Red size="5">小结:</font> <br> <spanclass="math display">\[地址长度=s+w位\]</span> <spanclass="math display">\[寻址空间=2^{s+w}\]</span> <spanclass="math display">\[块大小=2^w\]</span> <spanclass="math display">\[块数量=2^s\]</span> <spanclass="math display">\[cache的行数是m\]</span> <spanclass="math display">\[cache中行的tag标记位为s位\]</span></li><li><font color=Red>(**)</font><font color=Red size="4">组相连映射:</font><br></li><li>cache分为若干个组，每个组包含一些行，内存块映射到某个组中的任意一行<br></li><li>使用组号来决定是cache的哪个组，比较tag标记来确定是否命中 <br></li><li>以2路组关联映射为例：<br></li></ul><table><thead><tr class="header"><th style="text-align: center;">Tag</th><th style="text-align: center;">Set</th><th style="text-align: center;">Word</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">9 bit</td><td style="text-align: center;">13 bit</td><td style="text-align: center;">2 bit</td></tr></tbody></table><ul><li><font color=Red size="5">小结:</font> <br><font color=Red>(**)</font> <br> <spanclass="math display">\[内存地址长度为s+w位\]</span> <spanclass="math display">\[可寻址内存空间为2^{s+w}个字或字节\]</span> <spanclass="math display">\[内存块或cache行大小为2^w个字或字节\]</span> <spanclass="math display">\[内存中的块数为2^s\]</span> <spanclass="math display">\[cache中每组有k行\]</span> <spanclass="math display">\[总共分为v组，需要用d位来标识，v=2^d\]</span><span class="math display">\[cache总行数为kv=k * 2^d，标志位等于s-d\]</span></li></ul>          </div></p></li></ul><h3 id="多级cache">多级Cache</h3><h4id="集成度的提高使得cache可以放在cpu芯片上">集成度的提高使得cache可以放在CPU芯片上</h4><blockquote><p>比总线访问更快</p></blockquote><h4id="常用的是既使用片上cache也使用片外cache">常用的是既使用片上cache，也使用片外cache</h4><blockquote><p>L1在片上，L2在片外，用SRAM L2访问速度比DRAM快L2使用独立的数据通道</p></blockquote><h4 id="两级cache时的命中率">两级Cache时的命中率</h4><blockquote><p><img src="/image/res/23.png" /></p></blockquote><h2 id="重点知识点-3"><font color=Red>重点知识点:</font></h2><h3 id="存储系统特征">存储系统特征</h3><ul><li>Location位置：内部，外部</li><li>Capacity容量：字节数，可寻址单元数</li><li>Unit of transfer传送单位</li><li>Access method访问方式：顺序存取，直接存取，随机存取，关联存取</li><li>Performance性能：访问时间，存储周期，传输速率</li><li>Physical type物理类型：半导体，磁介质，光学材料，其他</li><li>Physicalcharacteristics物理特征：衰减，易失性，非易失性，可擦除性</li><li>Organisation组织形式</li></ul><h3id="命中率访问时间等计算"><font color="#0099ff">命中率、访问时间等计算</font></h3><h4 id="根据命中率计算访问时间">根据命中率计算访问时间</h4><h4id="根据访问时间的预期计算命中率">根据访问时间的预期，计算命中率</h4><p><font color=Red>(*)</font> <spanclass="math display">\[h=\frac{N_C}{N_c+N_m}\]</span>h：Cache命中率；<br>Nc：Cache完成存取的次数；<br>Nm：主存完成存取的次数<span class="math display">\[t_a=h*t_c+(1-h)*t_m\]</span>ta：Cache/主存系统的平均访问时间； tc：Cache存取周期；tm：主存存取的周期</p><h4 id="读写性能综合计算">读写性能综合计算</h4><h4 id="考虑写回策略的计算">考虑写回策略的计算</h4><blockquote><p>具体见补充写策略</p></blockquote><h3 id="直接映射算法"><font color=Red>直接映射算法:</font></h3><p><img src="/image/res/12.png" /> * 直接映射Cache组织 <imgsrc="/image/res/13.png" /> * 直接映射行表</p><table><thead><tr class="header"><th>Cache line</th><th>Main Memory blocks held</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0, m, 2m, 3m, ...</td></tr><tr class="even"><td>1</td><td>1, m+1, 2m+1, 3m+1, ...</td></tr><tr class="odd"><td>...</td><td></td></tr><tr class="even"><td>m-1</td><td>m-1, 2m-1, 3m-1, 4m-1, ...</td></tr></tbody></table><h3 id="全相联映射算法"><font color=Red>全相联映射算法:</font></h3><p><img src="/image/res/14.png" /> * 全相联映射Cache组织 <imgsrc="/image/res/15.png" /></p><h3 id="组相联映射算法"><font color=Red>组相联映射算法:</font></h3><ul><li>V组相联映射 <img src="/image/res/16.png" /></li><li>k路相联映射 <img src="/image/res/17.png" /> &gt; *V组相联映射同时也可以看做是k个直接映射的同时使用 <br> &gt; *cache被分成大小相等的k块，每块大小为v，称为K路相联映射 <br> &gt; *内存中的0 ~v-1行，通过直接映射方式，映射到cache中每一路的v行中。然后，内存中的v ~2v - 1也同样映射到每一路中的v行 <br> &gt; *内存中的每个块，可以映射到内存中的k路，也就是k行 <br> <imgsrc="/image/res/18.png" /></li><li>K路组相联cache组织 <img src="/image/res/19.png" /></li></ul><h3 id="替换算法">替换算法：</h3><h4id="直接映射只能替换到它对应的cache行">直接映射：只能替换到它对应的cache行</h4><h4 id="相联映射">相联映射：</h4><ul><li><font color=Red>(*)</font>Least Recently used (LRU) 最近使用原则&gt; 需要记录cache行的使用时间</li><li>First in first out (FIFO) 先进先出原则 &gt;在cache中时间最长的替换出去</li><li><font color=Red>(*)</font>Least frequently used(LFU)最少访问频率原则 &gt; 替换掉最少使用的块</li><li>Random 随机原则</li></ul><h2 id="补充-1"><font color=Red>补充:</font></h2><h3 id="映射算法举例">映射算法举例：</h3><h4 id="题目">题目：</h4><ul><li>学生1～16是内存块</li><li>计算机A~H是cache行</li><li>如何给学生分配计算机</li><li><font color=skyBlue size="4">直接映射:</font> &gt; <imgsrc="/image/res/20.png" /></li><li><font color=skyBlue size="4">全相联映射:</font> &gt; <imgsrc="/image/res/21.png" /></li><li><font color=skyBlue size="4">2路组关联映射:</font> &gt; <imgsrc="/image/res/22.png" /></li></ul><h3 id="写策略">写策略:</h3><h4 id="写直达">写直达:</h4><blockquote><p>所有写cache的操作同时会写存储器 <br>多个CPU时，能够监视存储器，以保证本地cache的数据及时更新 <br>减慢写的速度 <br> #### 写回法: 更新操作最开始只在cache中进行 <br>当cache更新的时候，设置“更新位” <br>当cache块要替换的时候，如果更新位设置，就更新存储器的数据 <br>部分存储器中的数据是无效的 <br> I/O需要通过cache来访问存储器 <br> ####例题: * 考虑具有32字节的行大小的缓存，需要30 ns来传送4字节字的主存储器 *对于在交换出缓存之前至少写入一次的任何行，并且假定写回法比写直达更有效 *在交换出缓存之前必须写入该行的平均次数是多少？对于写回法，每个脏行在交换时回写一次，时间为8 * 30=240 ns对于写直达，每次更新都需要将一个字写入主内存，耗时30 ns因此，如果至少写入一次的平均行在调出之前被写入8次以上， ###<font color="#0099ff">统一与分立cache</font> ####最初并不区分指令和数据，指令和数据都缓存到同一个cache 高命中率 ####采用两个L1 cache的架构，一个cache用于存放数据，另一个用于存放指令 * &gt;需要指令的时候，访问指令cache * &gt; 需要数据的时候，访问数据cache *减少了取指、解码、执行中的cache竞争，在流水线中很重要 ###<font color=Red>相联Cache例题：</font> *一个组相联cache，每块大小为4个16位字，组大小为2，cache总容量为4096个字。可缓存的内存容量为64k* 32位。设计一种cache的结构，并说明如何进行转换 *Cache，4096个字，每行4个16位字，每组2行</p></blockquote><table><thead><tr class="header"><th>Cache行号</th><th>行内字号</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0，1，2，3</td></tr><tr class="even"><td>1</td><td></td></tr><tr class="odd"><td>...</td><td></td></tr><tr class="even"><td>1023</td><td></td></tr></tbody></table><ul><li>总共1024行，每行4个字，每个字是16个bit，Cache总共512个组</li><li>内存64k * 32位</li></ul><table><thead><tr class="header"><th>内存</th><th>行内字号</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0，1</td></tr><tr class="even"><td>1</td><td></td></tr><tr class="odd"><td>...</td><td></td></tr><tr class="even"><td>65535</td><td></td></tr></tbody></table><ul><li><font color=skyBlue>内存块对应cache行，所以内存总共有32k个块</li><li>如果按字寻址，总共有128k字，需要17位地址</li><li>如果按字节寻址，总共有256k字节，需要18位地址</font></li><li><font color=Red size="4">分析:</font></li><li><blockquote><p>如果内存按字寻址，也就是以字为单位，那么内存总地址位：17位地址。</p></blockquote></li><li><blockquote><p>块内地址为2位。内存总共32k块，cache组为512组，所以cache的组号需要9位</p></blockquote></li><li><blockquote><p>标记位为：17-2-9=6位</p></blockquote></li><li><blockquote><p>如果内存按字节寻址，那么内存总地址位：18位地址。</p></blockquote></li><li><blockquote><p>一个块内有8个字节，块内地址为3位。内存总共32k块，cache组为512组，所以cache的组号需要9位</p></blockquote></li><li><blockquote><p>标记位为：18-3-9=6位</p></blockquote></li><li><blockquote><p><img src="/image/res/24.png" /></p></blockquote></li></ul><h1 id="第五章"><strong><em>第五章</em></strong></h1><h2 id="基本概念-4"><font color=Red>基本概念:</font></h2><h3 id="sram和dram">SRAM和DRAM</h3><h4id="随机读取存储器ram易失性的存储器需要持续供电">随机读取存储器(RAM)，易失性的存储器，需要持续供电</h4><h4 id="dram动态ram"><font color="#0099ff">DRAM(动态RAM)</font></h4><blockquote><p><img src="/image/res/DRAM.png" />构造简单，一个晶体管和一个电容，模拟信号，集成度高，价格便宜。需要定时刷新。主要用作内存(主存储器)用1个电容器来记录1bit</p></blockquote><h4 id="sram静态ram"><font color="#0099ff">SRAM(静态RAM)</font></h4><blockquote><p><img src="/image/res/SRAM.png" />构造复杂，6个晶体管组成的阵列，数字信号，每一位的体积大，价格昂贵。不需要定时刷新。主要用作cache</p></blockquote><h3 id="rom">ROM</h3><h4 id="只读存储器">只读存储器</h4><h4 id="非易失性永久存储">非易失性，永久存储</h4><h4id="重要的应用程序如微程序子程序库bios等">重要的应用程序，如微程序，子程序库，BIOS等</h4><h4 id="主要用于读也能写的存储器">主要用于读，也能写的存储器</h4><blockquote><p>PROM，EPROM，EEPROM，Flash <br> * PROM: <br>  一次可写，也就是可编程，需要特殊的设备去写入 <br> * EPROM: <br>  通过紫外线擦除，可以重复写入多次 <br> * EEPROM: <br>  直接对一个或多个字节进行定位后写入，写的时间比读长很多 <br> * Flash:<br>   采用块存储的方式，电擦除整个内存块 <br></p></blockquote><h3 id="内存刷新">内存刷新</h3><h4 id="dram必须刷新">DRAM必须刷新</h4><blockquote><p>每2~4ms刷新一次 <br><font color=Red>(*)</font><font color=Red>按行刷新</font> <imgsrc="/image/res/25.png" />写入1和后续刷新操作后，DRAM单元电容器上的电压恢复到正常值 <br>需要定时去刷新，否则由于电容自然放电，导致存储的电荷丢失，存储的1就变成了0</p></blockquote><h3 id="纠错和纠错码">纠错和纠错码</h3><ul><li>半导体器件容易因为多种原因导致错误</li><li>大多数现在存储系统包含检错和纠错的逻辑</li><li>通过附加位来实现检错和纠错，附加的位数称为纠错码</li><li>纠错码会导致需要保存的字长增加，占用更多的存储空间</li><li>常用的纠错码是汉明码，贝尔实验室的理查德.汉明发明</li></ul><h2 id="重点知识点-4"><font color=Red>重点知识点:</font></h2><h3 id="内存组织">内存组织:</h3><h4id="半导体存储器一般都是封装成芯片每个芯片里包含存储位元组成的阵列可以存储n-m的位元数据">半导体存储器一般都是封装成芯片，每个芯片里包含存储位元组成的阵列，可以存储N* M的位元数据</h4><h4 id="将多个存储芯片组织一个阵列">将多个存储芯片组织一个阵列</h4><blockquote><p>扩展内存使内存变大，可寻址空间更大扩展内存使内存变宽，每次读写的位数等多 <imgsrc="/image/res/26.png" /></p></blockquote><h4 id="例题">例题：</h4><ul><li>存储器芯片为1Mbit，需要组织成8MB的按字节寻址的存储系统。</li><li>需要多少个这样的芯片？</li><li>需要多少位存储器地址？</li><li>存储芯片如何组织？ <br>   <em>芯片数量:</em> 8Mbyte/1Mbit=64片<font color=skyBlue>(byte/bit=8)</font> <br>  <em>存储器地址位数:</em>8Mbyte按字节存储，需要寻址8M个存储单元，所以需要23位地址 <br></li></ul><h3 id="内存访问"><font color=Red>内存访问：</font></h3><h4 id="按行访问">按行访问：</h4><p><img src="/image/res/27.png" /></p><h4 id="网格访问">网格访问:</h4><p><img src="/image/res/28.png" /></p><h3 id="扩展内存">扩展内存：</h3><h4 id="内存变大">内存变大：</h4><blockquote><p><img src="/image/res/29.png" /> <img src="/image/res/30.png" /><font color=Red>地址总线变的更宽，用增加的地址总线来选择存储芯片</font></p></blockquote><h4 id="内存变宽">内存变宽：</h4><p><img src="/image/res/31.png" /> *使用多个存储器芯片，将存储器的数据位数进行扩宽 <br> *地址线用于所有的芯片 <br> *每个芯片保存每次输出的一部分内容单元，每次输出的数据是所有芯片输出之和<br> *数据总线变宽，存储容量变大（每个可寻址单元变大，寻址空间没有变大） <br><img src="/image/res/32.png" /> &gt;<font color=Red>地址空间没有扩展，但是数据总线的宽度扩展</font></p><h4 id="混合扩展">混合扩展:</h4><p><img src="/image/res/33.png" /></p><h3 id="内存地址解码">内存地址解码</h3><h4id="存储系统一般都会包含多个存储芯片">存储系统一般都会包含多个存储芯片</h4><h4id="地址解码就是为每个芯片生成片选信号的过程由解码器来完成">地址解码就是为每个芯片生成片选信号的过程。由解码器来完成</h4><p><img src="/image/res/34.png" /> <div class="note note-success">            <p>例题：<br> 假定CPU访问1KB的存储空间使用128 x 8bit 的存储芯片 <br>需要多少个存储芯片？总共需要多少根地址线，如何使用？ <br> 使用128 * 8bit的存储芯片 <br> 8 memory chips are needed 128x8 = 1024需要8个存储芯片才能达到1024的存储空间 <br> 需要3个地址线来选择存储芯片<br> 7个低位地址线来选择芯片内的存储单元 <br></p>          </div></p><h4 id="section"><img src="/image/res/35.png" /></h4><h4 id="解码策略">解码策略：</h4><ul><li>全地址解码：<br> &gt; 所有的地址线用于指定存储位置 <br> &gt;每个物理存储位置都由唯一的地址来标识 <br></li><li>部分地址解码: <br> &gt;如果只需要使用部分地址，就不需要实现全部的地址空间寻址 <br> &gt;只需要地址线的一部分用于物理寻址</li></ul><h3 id="内存刷新的计算">内存刷新的计算:</h3><h4id="一般内存会组织成n-x-n-x-m-bit的形式其中m为一次读写的位数比如256mb的内存组织成16k-x-16k-x-8bit的形式">一般内存会组织成Nx N x m bit的形式，其中m为一次读写的位数，比如256MB的内存，组织成16k x16k x 8bit的形式</h4><h4 id="按行刷新刷新总时间行数-单行的刷新时间">按行刷新，刷新总时间=行数* 单行的刷新时间</h4><h4 id="刷新会导致内存带宽的损失">刷新会导致内存带宽的损失</h4><h4id="内存行数越多刷新带来的内存带宽的损失越大">内存行数越多，刷新带来的内存带宽的损失越大</h4><h3 id="检错过程">检错过程:</h3><p><img src="/image/res/36.png" /> * 原始数据M通过函数f计算得到校验码K<br> * 校验码K和M同时存入到存储器中 <br> *输出时，用存储器中存储的M，再次通过函数f进行计算，得到K’，和存储的K进行比较<br> &gt; 没有错误，直接将存储的M输出 <br> &gt;有错误，但是可以纠错，将存储的M和K进入纠错器，纠错后将正确数据输出 <br>&gt; 有错误，并且无法纠错，直接输入错误信号 <br></p><h3 id="汉明纠错码"><font color=Red>汉明纠错码</font></h3><h4 id="汉明码图示">汉明码图示：</h4><p><img src="/image/res/37.png" /></p><h4 id="汉明纠错码的原理">汉明纠错码的原理:</h4><ul><li>4个数据位，3个纠错位</li><li>数据位填到相交的位置</li><li>不相交的部分填入数字，使得每个圆中的1的个数为偶数</li><li>可以发现并纠正1个错误</li><li><font color=Red>(*)</font><span class="math display">\[2^K – 1 &gt;=M + K\]</span> 数据位数M，纠错码位数为K(计算纠错码位数) ####<font color=Red>汉明纠错码生成过程:</font></li></ul><table style="width:100%;"><thead><tr class="header"><th>Bit position</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th></tr></thead><tbody><tr class="odd"><td>Position number</td><td>1100</td><td>1011</td><td>1010</td><td>1001</td><td>1000</td><td>0111</td><td>0110</td><td>0101</td><td>0100</td><td>0011</td><td>0010</td><td>0001</td></tr><tr class="even"><td>Data bit</td><td>D8</td><td>D7</td><td>D6</td><td>D5</td><td></td><td>D4</td><td>D3</td><td>D2</td><td></td><td>D1</td><td></td><td></td></tr><tr class="odd"><td>check bit</td><td></td><td></td><td></td><td></td><td>C8</td><td></td><td></td><td></td><td>C4</td><td></td><td>C2</td><td>C1</td></tr></tbody></table><blockquote><p><span class="math display">\[C1 = D1 \bigoplus D2 \bigoplus D4\bigoplus D5 \bigoplus D7\]</span> <span class="math display">\[C2 = D1\bigoplus D3 \bigoplus D4 \bigoplus D6 \bigoplus D7\]</span> <spanclass="math display">\[C4 = D2 \bigoplus D3 \bigoplus D4 \bigoplusD8\]</span> <span class="math display">\[C8 = D5 \bigoplus D6 \bigoplusD7 \bigoplus D8\]</span><font color="#0099ff">计算C1的所有数据位，它的位置的最后一位都是1计算C2的数据位，它的位置的倒数第二位是1，如此类推</font></p></blockquote><h3id="汉明纠错码例题"><font color="#0099ff">汉明纠错码例题：</font></h3><h4id="假设8位数据位是00111001数据位d1在最右边校验位计算如下">假设8位数据位是00111001，数据位D1在最右边。校验位计算如下</h4><blockquote><p><span class="math display">\[C1 = 1 \bigoplus 0 \bigoplus 1 \bigoplus1 \bigoplus 0 = 1\]</span> <span class="math display">\[C2 = 1 \bigoplus0 \bigoplus 1 \bigoplus 1 \bigoplus 0 = 1\]</span> <spanclass="math display">\[C4 = 0 \bigoplus 0 \bigoplus 1 \bigoplus 0 =1\]</span> <span class="math display">\[C1 = 1 \bigoplus 1 \bigoplus 0\bigoplus 0 = 0\]</span></p></blockquote><h4id="假如数据位3发生了错误从0变成了1校验位重新计算的时候我们得到如下结果">假如数据位3发生了错误，从0变成了1。校验位重新计算的时候，我们得到如下结果：</h4><blockquote><p><span class="math display">\[C1 = 1 \bigoplus 0 \bigoplus 1 \bigoplus1 \bigoplus 0 = 1\]</span> <span class="math display">\[C2 = 1 \bigoplus1 \bigoplus 1 \bigoplus 1 \bigoplus 0 = 0\]</span> <spanclass="math display">\[C4 = 0 \bigoplus 1 \bigoplus 1 \bigoplus 0 =0\]</span> <span class="math display">\[C8 = 1 \bigoplus 1 \bigoplus 0\bigoplus 0 = 0\]</span></p></blockquote><h4id="根据数据生成的新纠错码和老纠错码进行对比得到故障字">根据数据生成的新纠错码和老纠错码进行对比，得到故障字：</h4><blockquote><p><img src="/image/res/38.png" /></p></blockquote><h4id="故障字是0110表示第6位也就是数据位d3发生了错误">故障字是0110，表示第6位，也就是数据位D3，发生了错误</h4><h2 id="补充-2"><font color=Red>补充:</font></h2><h3id="非易失性存储器的特性"><font color=Red>(*)</font>非易失性存储器的特性</h3><blockquote><p>在非易失性存储器中，一旦记录的信息不会恶化，直到故意改变，不需要电力来保留信息In a non-volatile(非易失) memory, information once recordedremainswithout deterioration(衰减) until deliberately(故意)changed and noelectrical power is needed to retain information</p></blockquote><h1 id="第六章"><strong><em>第六章</em></strong></h1><h2 id="基本概念-5"><font color=Red>基本概念:</font></h2><h3id="磁盘中的各个术语磁盘磁头磁道扇区柱面">磁盘中的各个术语，磁盘，磁头，磁道，扇区，柱面</h3><p><img src="/image/res/39.png" /></p><ul><li>磁盘：<br> <div class="note note-warning">            <p>磁盘是在圆形非磁性盘片上涂了一层磁性材料 <br>数据通过读写头来写入或者从磁盘中读取 <br> 直接访问存储方式 <br></p>          </div></li><li><font color=Red>(*)</font>磁道： <div class="note note-warning">            <p>磁盘划分为若干个同心的环，这样的圆环称为磁道，<font color=skyBlue>数据存在磁道上</font></p>          </div></li><li>扇区： <br> <div class="note note-warning">            <p>每个磁道划分为若干个扇区。每个磁道一般包含几百个扇区。扇区是数据存储的最小单位，<font color=skyBlue>通用的扇区大小是512个字</font></p>          </div></li><li>柱面： <div class="note note-warning">            <p>每个盘面上相对应的位置的一组磁道设置为一个柱面，数据按照柱面进行存储。可以减少磁头的移动，提高数据传输的速度，<font color=skyBlue>每个盘片有2个磁头</font></p>          </div></li></ul><h3 id="磁盘访问的时间">磁盘访问的时间:</h3><h4 id="寻道时间seek-time">寻道时间(seek time):</h4><blockquote><p>磁头移动到数据所在磁道需要的时间。由磁头移动时间决定。<font color=skyBlue>一般是10ms</font><br></p></blockquote><h4 id="旋转延时rotational-delay">旋转延时(rotational delay):</h4><blockquote><p>磁头到达磁道后，到数据所在扇区从当前位置移动到磁头下面所需要的时间。<font color=skyblue>由磁盘转速决定</font><br></p></blockquote><h4 id="传送时间transfer-time">传送时间(transfer time):</h4><blockquote><p>指的是数据定位后开始进行实际传送的时间 <br></p></blockquote><h4 id="存取时间access-time">存取时间(Access time):</h4><blockquote><p><span class="math display">\[存取时间Access time =寻道时间 Seek+旋转延迟 rotational delay\]</span></p></blockquote><h3 id="raid">RAID:</h3><ul><li>Redundant Array of Independent Disks 冗余独立磁盘阵列</li><li>常用的有7个级别</li><li>一组物理磁盘，由操作系统驱动形成单一的逻辑硬盘</li><li>数据在不同的物理盘上分布</li><li>使用冗余容量来保存校验信息</li><li>作用：增加容量，提高可靠性，提高读写性能</li></ul><h3 id="光盘">光盘</h3><ul><li>Compact Disk——CD：压缩光盘</li><li>数据就是用这个膜的表面上的微小凹坑来表示</li><li>采用的是一条螺旋线，从中心开始往外旋转，一直到最外边。最内和最外的扇区的长度就是一样的</li><li>盘片旋转的线速度恒定</li><li>种类: &gt; CD，CD-R，CD-RW，DVD，DVD-W，HD-DVD，Blue-ray</li></ul><h3 id="磁带">磁带</h3><ul><li>顺序访问</li><li>速度慢</li><li>价格便宜</li><li>主要用于备份和恢复</li></ul><h2 id="重点知识点-5"><font color=Red>重点知识点:</font></h2><h3 id="磁盘容量的计算">磁盘容量的计算:</h3><ul><li>磁盘以相同的角速度旋转</li><li>每个磁道上的扇区数相同</li><li>内圈的存储密度决定了磁盘的容量</li><li><span class="math display">\[磁盘容量=每扇区字节数 * 磁道的扇区数 *磁道数 * 盘面数\]</span></li></ul><h3id="磁盘读写速度的计算"><font color=Red>磁盘读写速度的计算</font></h3><h4 id="transfer-time---t-传送时间t"><font color=Red>(**)</font><font color="#0099ff">Transfer time - T 传送时间T</font></h4><blockquote><p><span class="math display">\[T = \frac{b}{rN}\]</span> b = number ofbytes to be transferred 需要传送的字节数 N = number of bytes on a track一个磁道上的字节总数 r = rotation speed, in revolutions per second旋转速度</p></blockquote><h4id="the-total-average-access-time-including-transfer-time-总的平均访问时间包括传输时间"><font color=Red>(**)</font><font color="#0099ff">The total average access time (including transfertime) 总的平均访问时间，包括传输时间</font></h4><blockquote><p><span class="math display">\[T_a = T_s + \frac{1}{2r} +\frac{b}{rN}\]</span> 总的时间=寻道时间+平均旋转延时+传送时间 Ts = seektime 寻道时间 1/2r is the average Rotational latency 平均旋转延时</p></blockquote><h3 id="raid0">RAID0</h3><ul><li>没有冗余</li><li>数据条带跨磁盘</li><li>存储能够提升访问速度</li><li>设计简单，容易实现没有容错机制</li><li>可用空间为所有磁盘空间之和</li><li>适用于成本比可靠性的要求更高的场景，比如视频生产和编辑</li></ul><h4 id="raid0映射图">RAID0映射图</h4><p><img src="/image/res/RAID0.png" /></p><h3 id="raid1">RAID1</h3><ul><li>全镜像</li><li>单个磁盘读，两个磁盘写</li><li>故障恢复简单</li><li>价格昂贵</li><li>可用空间为全部空间的1/2</li><li>适用于可靠性要求高的场合</li></ul><h4 id="raid1映射图">RAID1映射图</h4><p><img src="/image/res/RAID1.png" /></p><h3 id="raid2">RAID2</h3><ul><li>磁盘分为数据盘和纠错盘</li><li>采用汉明纠错码生成纠错码，保存在纠错盘中</li><li>冗余度很高，价格昂贵</li><li>读写比较慢，需要全部磁盘参与计算</li><li>根据数据盘的数量决定冗余盘的数量。例如，4个数据盘，需要3个纠错盘；8个数据盘，需要4个纠错盘</li><li>使用的不多</li></ul><h4 id="raid2映射图">RAID2映射图</h4><p><img src="/image/res/RAID2.png" /></p><h3 id="raid3">RAID3</h3><ul><li>只设置了一个冗余盘</li><li>奇偶校验</li><li>损坏一个盘，可以通过其他盘重构数据</li><li>写比较慢，需要进行奇偶校验位计算</li><li>读写都是全部盘参与</li><li>可用空间为（N-1）/N</li></ul><h4 id="raid3映射图">RAID3映射图</h4><p><img src="/image/res/RAID3.png" /></p><h3 id="raid4">RAID4</h3><ul><li>只设置了一个校验盘</li><li>各个数据盘独立</li><li>数据盘采用大条带</li><li>数据盘写入数据时，同时根据奇偶校验，将校验位写到校验盘</li><li>读数据可以并行进行，写入需要计算校验，比较慢</li><li>校验盘的压力比较大</li><li>可用空间为（N-1）/N</li></ul><h4 id="raid4映射图">RAID4映射图</h4><p><img src="/image/res/RAID4.png" /></p><h3 id="raid5">RAID5</h3><ul><li>只设置了一个校验盘，和RAID4类似</li><li>校验条带轮流分布在各个盘上</li><li>避免RAID4的校验盘的瓶颈</li><li>可用空间为（N-1）/N</li><li>通常用在网络服务器上</li></ul><h4 id="raid5映射图">RAID5映射图</h4><p><img src="/image/res/RAID5.png" /></p><h3 id="raid6">RAID6</h3><ul><li>双校验盘</li><li>不同的算法，生成2个奇偶校验码，放在不同的校验条带上</li><li>校验条带轮流分布在各个盘上</li><li>可靠性高，写速度比较慢</li><li>可用空间为（N-2）/N</li><li>通常用在可靠性要求较高的场合，比如数据库服务器</li></ul><h4 id="raid6映射图">RAID6映射图</h4><p><img src="/image/res/RAID6.png" /></p><h3 id="典型光盘的容量">典型光盘的容量</h3><ul><li>CD：650MB，大概70分钟的音频</li><li>DVD：4.7GB</li><li>双面双层DVD：17GB</li><li>HD-DVD：单面单层15GB</li><li>Blue-ray：单层 25GB</li></ul><h2 id="补充-3"><font color=Red>补充:</font></h2><h3 id="存储器存取方式">存储器存取方式：</h3><h4id="顺序存取"><font color=Red>(*)</font><font color="#0099ff">顺序存取：</font></h4><div class="note note-primary">            <p>数据以线性的方式存放在存储介质中。读取数据必须按照顺序的方式，从当前的位置按照顺序移动到数据所在的位置进行读取。典型的顺序存取是_磁带_</p>          </div><h4id="直接存取"><font color=Red>(*)</font><font color="#0099ff">直接存取：</font></h4><div class="note note-primary">            <p>数据按块存储在介质中，并且每个块都有一个唯一的地址。存取时，先按照这个唯一地址到达所在的块，然后在块中，顺序搜索到数据。典型的直接存取是_硬盘_</p>          </div><h4 id="随机存取"><font color="#0099ff">随机存取：</font></h4><h5id="每个存取单元都有一个唯一的地址通过寻址机制可以直接找到这个位置不依赖于之前的存取操作所在的位置典型的随机存取是_内存_">每个存取单元都有一个唯一的地址，通过寻址机制可以直接找到这个位置，不依赖于之前的存取操作所在的位置。典型的随机存取是_内存_</h5><h4 id="关联存取"><font color="#0099ff">关联存取：</font></h4><h5id="关联存取是通过对字中的部分内容进行比较如果匹配就进行存取操作关联存取是对字的内容进行比较不是地址寻址典型的关联存取是_cache_">关联存取是通过对字中的部分内容进行比较，如果匹配就进行存取操作。关联存取是对字的内容进行比较，不是地址寻址。典型的关联存取是_Cache_</h5><h3 id="磁盘io传输的时序">磁盘IO传输的时序</h3><p><img src="/image/res/40.png" /></p><ul><li>读写之前，首先要等待设备和通道空闲 <br></li><li>寻道时间：磁头从当前位置移动到数据所在的磁道的时间 <br></li><li>旋转延迟：数据所在的扇区旋转到磁头可以读写的位置 <br></li><li>数据传输：数据实际的传送阶段 <br></li><li>存取时间：寻道时间+旋转延迟</li></ul><h3id="磁盘读写速度的计算例题"><font color="#0099ff">磁盘读写速度的计算例题</font></h3><ul><li>旋转速度为15000转每分钟</li><li>每个磁道有500个扇区</li><li>每个扇区512个字节</li><li>平均寻道时间是4ms</li><li>如果文件大小是1.25M，总共需要多长时间？</li><li>文件按照扇区和磁道顺序存储</li><li>文件内容完全随机存储 <br> &gt; 平均寻道时间4ms <br> &gt;每个道旋转一圈需要4ms <br> &gt; 第一个道的总传输时间: 4ms + 2ms + 4ms =10 ms 需要10ms <br> &gt;后续的磁道不需要寻道时间，只需要一个平均旋转延迟，定位磁头到第一个数据扇区:2ms + 4ms=6ms <br> &gt; 总的时间 = 10 ms + 4 x (2+4) ms = 34 ms首个磁道时间+4个其他磁道时间=34ms <br></li></ul><h3id="磁盘有关计算合集例题此处引用的是未改答案前的版本"><font color="#0099ff">磁盘有关计算合集例题：</font><em>(此处引用的是未改答案前的版本)</em></h3><h5id="考虑一个有8个面的磁盘驱动器每面有512个磁道每道上有64个扇区扇区大小为1kb平均寻道时间是8ms道间移动时间是1.5ms磁盘转速为3600rpm可以读取同一柱面上的连续磁道而磁头不需要移动">考虑一个有8个面的磁盘驱动器，每面有512个磁道，每道上有64个扇区，扇区大小为1KB。平均寻道时间是8ms,道间移动时间是1.5ms，磁盘转速为3600rpm。可以读取同一柱面上的连续磁道而磁头不需要移动。</h5><ul><li>(a)磁盘容量是多少？</li><li>(b)平均存取时间是多少？假设某文件被存储在连续柱面的连续扇区和连续磁道上，起始位置为柱面i上第0道的第0号扇区。</li><li>(c)估计传送5MB大小的文件所需要的时间。</li><li>(b)突发传送率是多少？ <div class="note note-danger">            <ul><li><ol type="a"><li><span class="math display">\[磁盘容量为：8 ∗ 512 ∗ 64 ∗ 1𝐾B =256MB\]</span></li></ol></li><li><ol start="2" type="a"><li><span class="math display">\[平均寻道时间：8𝑚s\]</span> <spanclass="math display">\[旋转延迟时间\frac{60}{3600 * 2} * 1000 =8.3𝑚s\]</span> <span class="math display">\[平均存取时间为：8 + 8.3 =16.3𝑚s\]</span></li></ol></li><li>(c)<span class="math display">\[5MB需要\frac{5MB}{64KB}=80个磁道\]</span> (涉及MB，KB等的计算先将其化为B) <br> <spanclass="math display">\[由于总共有8个盘，所以总共是 \frac{80}{8} =10个柱面\]</span>传送文件所需时间主要包括寻道时间，旋转延迟，读取时间，道间移动时间 <br><span class="math display">\[读取时间为每个柱面 \frac{60}{3600} * 8 *1000 = 133.3ms\]</span> <spanclass="math display">\[传送5MB大小文件所需时间为：（8 + (8.3 + 133.3)）+9 * (8.3 + 133.3 + 1.5) = 1437.5ms\]</span>“+”前的式子：第一个柱面，“+”后的式子：其他柱面 <br></li><li>(d)<span class="math display">\[突发传送率为：\frac{3600}{60} * 64 *1𝐾B = 3.84 MB/S\]</span></li></ul>          </div></li></ul><h1 id="第七章"><strong><em>第七章</em></strong></h1><h2 id="基本概念-6"><font color=Red>基本概念:</font></h2><h3 id="io模块">I/O模块</h3><ul><li>I/O模块不仅实现了外设和系统总线的互连，同时还需要完成外设和系统总线之间的通信逻辑</li><li>I/O模块向上通过系统总线或中央交换器与处理器和存储器进行连接</li><li>I/O模块向下通过专用的数据线与一个或多个外设连接</li><li>I/O模块的功能：控制和定时，处理器通信，设备通信，数据缓冲，检错处理</li></ul><h4 id="通用的io模块模型">通用的I/O模块模型</h4><p><img src="/image/res/41.png" /></p><h4 id="外设结构框图">外设结构框图</h4><p><img src="/image/res/46.png" /></p><h4 id="io模块框图">I/O模块框图</h4><p><img src="/image/res/47.png" /></p><h3 id="三种io技术">三种I/O技术</h3><blockquote><p>编程式I/O，中断式I/O，直接存储器访问</p></blockquote><h4id="编程式io"><font color=Red>(*)</font><font color="#0099ff">编程式I/O</font></h4><blockquote><p><em>处理器能直接控制I/O模块</em>，感知I/O模块的状态，并且下发读、写命令，进行数据的传输<br> <font color=skyBlue>CPU下发指令后，需要等待I/O模块完成操作</font><br> <em>浪费CPU时间</em> <br> <img src="/image/res/42.png" /></p></blockquote><h4 id="中断式io"><font color="#0099ff">中断式I/O</font></h4><blockquote><p><em>CPU不需要等待</em>，也不需要不停地检查I/O设备的状态，<em>而是可以继续处理后续的指令</em><br><font color=skyBlue>I/O模块在准备好和处理器进行数据交换的时候，它会发起一个中断请求</font><br>处理器发现有中断，就进行中断处理。不用一直等待，降低了CPU的无效等待时间，提高了处理效率<br> <img src="/image/res/43.png" /></p></blockquote><h4id="dma"><font color=Red>(*)</font><font color="#0099ff">DMA</font></h4><blockquote><p>Direct Memory Access(直接存储器访问) <br><font color=skyBlue>能够实现内存和 I/O直接传输数据的模块</font> <br><font color=Red>(*)</font>DMA代替CPU完成内存和 I/O之间的传输 <br>减少了CPU的参与度，进一步提高了CPU的效率 <br> <imgsrc="/image/res/44.png" /></p></blockquote><h3 id="周期窃取"><font color=Red>(*)</font>周期窃取:</h3><ul><li>DMA需要使用系统总线来管理数据的传输</li><li>或者是处理器不需要系统总线的时候工作，或者强制处理器临时挂起操作，以便DMA模块使用总线</li><li><strong><em>强制处理器临时挂起的方式称为“周期窃取” ，</em></strong>相当于说DMA模块窃取了一个总线周期</li><li>和中断不一样，不需要保存上下文信息，<font color="#0099ff">CPU仅仅是挂起一个时钟周期</font></li></ul><h3 id="io通道和io处理器">I/O通道和I/O处理器</h3><h5id="io模块经过增强后成为一个有自主控制权的独立处理器具有定制的指令集cpu指示io处理器在内存中执行io程序无需cpu干预">I/O模块经过增强后，成为一个有自主控制权的独立处理器，具有定制的指令集。CPU指示I/O处理器在内存中执行I/O程序，无需CPU干预。</h5><h5id="io处理器负责处理大部分任务包括控制终端">I/O处理器负责处理大部分任务，包括控制终端</h5><h5id="不对io通道和io处理器做区分统称为io通道">不对I/O通道和I/O处理器做区分，统称为I/O通道</h5><h2 id="重点知识点-6"><font color=Red>重点知识点:</font></h2><h3 id="设备和cpu之间的数据传输过程">设备和CPU之间的数据传输过程</h3><ul><li>CPU检测I/O模块的状态</li><li>I/O模块返回状态</li><li>如果就绪，CPU请求数据</li><li>I/O模块从设备中获取数据</li><li>I/O模块传输数据给CPU</li></ul><h3 id="io模块和处理器的通信功能">I/O模块和处理器的通信功能</h3><blockquote><p>命令解码 <br> 地址识别 <br> 传输传送 <br></p></blockquote><h3 id="编程式io模块工作流程">编程式I/O模块工作流程</h3><blockquote><p>CPU需要执行I/O操作的时候，CPU发送指令，请求I/O操作 <br>I/O模块执行对应的操作，执行完成后，设置状态位 <br>在待期间，CPU会周期性地检查状态，看I/O模块是不是执行完了 <br>I/O在执行完成之后，不会通知CPU它的完成状态，也不会发送中断信息给CPU <br>在这个期间，CPU只能等待，或者过一会儿再来检查状态位 <br></p></blockquote><h3 id="io地址方式">I/O地址方式</h3><h4id="内存映射io地址"><font color="#0099ff">内存映射I/O地址</font></h4><blockquote><p>地址空间分为2个部分：一部分给内存，一部分给I/O <br>能够使用相同的指令去传输数据 <br> 不需要额外的信号和指令 <br>浪费内存空间 <br></p></blockquote><h4id="独立映射io地址"><font color="#0099ff">独立映射I/O地址</font></h4><blockquote><p><em>独立地址空间</em> <br> 需要I/O或内存的选择线 <br>需要专用的I/O指令 <br> 不浪费内存空间 <br></p></blockquote><h3id="识别中断设备的方式"><font color=Red>识别中断设备的方式</font></h3><h4 id="独立中断线">独立中断线</h4><blockquote><p>多个中断线，每个设备有独立的的中断请求 <br></p></blockquote><h4 id="软件轮询">软件轮询</h4><blockquote><p>中断服务程序轮询每个I/O模块，以确定是哪个模块导致了中断 <br>状态寄存器：I/O模块产生中断后，写入状态寄存器。处理器查询_状态寄存器_，确定中断的I/O模块<br> 一旦识别出正确的模块，处理器将分支到该设备的设备服务例程 <br></p></blockquote><h4 id="硬件轮询"><font color=Red>(*)</font>硬件轮询</h4><blockquote><p>所有I/O模块共享中断请求线 <br> 处理器发现中断，发出一个中断应答信号<br> 信号通过IO模块传播，直到到达请求的模块 <br>请求模块通过设置一个_向量来响应_ <br>处理器用这个向量作为指针指向设备服务程序 <br></p></blockquote><h4 id="总线仲裁">总线仲裁</h4><blockquote><p>I/O模块必须首先获得总线控制权，然后才能触发中断请求线 <br>当处理器检测到中断时，它会在中断确认线上做出响应 <br>请求模块将其向量放置在数据线上 <br></p></blockquote><h3 id="多重中断处理方式">多重中断处理方式</h3><h4 id="fifo">FIFO</h4><blockquote><p>先来先处理，没有优先级 <br></p></blockquote><h4id="多个中断线每个中断线都有优先级">多个中断线，每个中断线都有优先级</h4><h4id="硬件或软件轮询轮询顺序决定了优先级">硬件或软件轮询，轮询顺序决定了优先级</h4><h4id="总线仲裁仲裁方式决定了优先级">总线仲裁，仲裁方式决定了优先级</h4><h3 id="dma工作流程"><font color="#0099ff">DMA工作流程</font></h3><ul><li>CPU告诉DMA控制器：操作类型，设备地址，内存块开始地址，数据数量</li><li>CPU继续做其他工作</li><li>DMA控制器处理传输，完成后发出中断</li><li>I/O设备到内存，或者内存到I/O设备</li><li>地址自动增加，计数器更新</li><li>CPU只在传输的开始和结束时介入 <img src="/image/res/48.png" /></li></ul><h3id="周期窃取工作原理"><font color="#0099ff">周期窃取工作原理</font></h3><ul><li>DMA控制器获得一个时钟周期的总线控制权，在这个时钟周期内传送一个字的数据，传送完成后，将总线控制权还给处理器</li><li>周期窃取不是一个中断。中断处理时，CPU需要保存上下文后再进行中断处理。而在周期窃取中，CPU不需要保存上下文，仅仅是挂起一个周期，然后可以继续访问总线，进行后续的操作。并且挂起只会发生在CPU需要访问总线前的这个周期。如果当前的操作不需要使用总线，那么CPU可以继续进行</li><li>周期窃取会导致CPU挂起一个时钟周期，所以会使得CPU的处理减慢一点点。但是对于数据传输来说，这种方式的效率比编程式I/O或者中断式I/O都要高<img src="/image/res/49.png" /></li></ul><h1 id="第八章"><strong><em>第八章</em></strong></h1><h2 id="基本概念-7"><font color=Red>基本概念:</font></h2><h3 id="进程和进程调度">进程和进程调度:</h3><h4 id="进程">进程</h4><p>进程是正在执行的程序，进程是在计算机上运行的程序的实例，进程是可以分配给处理器并在处理器上执行的实体进程是一种活动单元，其特征是执行一系列指令、当前状态和一组相关的系统指令<font color="#0099ff">进程是动态运行的，而程序是静态的</font></p><h4 id="进程处理的五个状态">进程处理的五个状态</h4><ul><li>新建状态：调度程序提交一个程序，操作系统为这个程序创建一个进程，并将进程移入就绪状态</li><li>就绪状态：进程已经准备就绪，等待处理器的执行</li><li>运行状态：进程正在由处理器执行</li><li>等待状态：进程在等待资源，处于挂起状态</li><li>终止状态：进程运行结束</li></ul><h4 id="进程调度">进程调度:</h4><ul><li>决定多道程序运行效率</li><li>长期调度：决定哪些程序需要加到待处理的进程池</li><li>中期调度：决定哪些进程能加载到内存中</li><li>短期调度：决定哪个进程下一个处理</li></ul><h4 id="进程交换"><font color="#0099ff">进程交换:</font></h4><ul><li>操作系统维护了一个进程的长期队列，队列中的进程放在磁盘上</li><li>内存有空间了，长期队列中的一个进程就会调入到内存中。当进程执行完成后，它就从内存中调出</li><li>如果内存中所有的进程都处于阻塞状态，把某个阻塞的进程“交换”到一个中间队列中，这个中间队列保存的都是临时从内存中调出的进程。然后，从这个中间队列中调入一个已经就绪的进程，或者从长期队列中调度一个新的进程到内存中。这个过程称为“交换”</li><li><font color=skyBlue>交换示意图:</font></li><li><img src="/image/res/51.png" /></li></ul><h3 id="操作系统">操作系统:</h3><h4id="最基本的系统程序它在用户和计算机之间搭起了一个桥梁为用户使用计算机提供了接口可以更方便使用计算机">最基本的系统程序，它在用户和计算机之间搭起了一个桥梁，为用户使用计算机提供了接口，可以更方便使用计算机</h4><h4 id="操作系统的功能">操作系统的功能：</h4><ul><li>程序创建和执行</li><li>I/O设备访问</li><li>文件访问控制</li><li>系统访问</li><li>错误检测和处理</li><li>统计</li></ul><h4 id="操作系统类型">操作系统类型：</h4><ul><li>是否支持批处理 <br> &gt; 交互式: 用户通常用键盘或显示器与计算机交互<br> &gt; 批处理:多个用户程序打包后，操作员成批提交给计算机进行处理，处理结束后，打印结果<br></li><li>是否支持多道程序 <br> &gt; 单道程序: 处理器一次只能处理一个程序 <br>&gt; 多道程序:处理器一次可以处理多个程序，多个程序同时装入内存，处理器在程序之间进行切换，同时处理<br></li></ul><h3 id="内存分区">内存分区:</h3><h4id="将内存分为几个部分分配给包括操作系统在内的进程">将内存分为几个部分，分配给包括操作系统在内的进程</h4><h4 id="固定分区">固定分区:</h4><ul><li><font color=skyBlue>分区大小固定，但不一定都是一样大</font></li><li>进程分配内存时，分配到能容纳它的最小分区</li><li>存在内存浪费的现象</li></ul><h4 id="可变分区">可变分区:</h4><ul><li>按进程要求分配</li><li>会产生内存碎片 <br> &gt;碎片：在内存的最后会留下一个空块，太小不能使用(当所有进程都阻塞了，进程交换出去，会产生另一个空块；当进程执行完交换出去后，新的进程进来了，可能会产生另一个空块)</li><li>合并或紧缩法处理碎片 <br> &gt;合并法：将相邻的空块合并成一个大的空块 <br> &gt;紧缩法：检索内存，将所有的空块移动形成一个大的空块。类似磁盘的去碎片化<br></li><li>动态分区的效果 <img src="/image/res/50.png" /></li></ul><h3 id="重载问题">重载问题</h3><h4id="进程重新加载到内存中没有机制保证会在同一个位置">进程重新加载到内存中，没有机制保证会在同一个位置</h4><h4id="采用固定地址的话那么进程被交换出去后再交换进来进程的内存地址发生了变化就会出现问题"><font color="#0099ff">采用固定地址的话，那么进程被交换出去后，再交换进来，进程的内存地址发生了变化，就会出现问题</font></h4><h4id="采用逻辑地址和物理地址的方法物理地址是进程在内存中的实际单元地址而逻辑地址是相对于进程起始地址的一个相对地址">采用逻辑地址和物理地址的方法。物理地址是进程在内存中的实际单元地址，而逻辑地址是相对于进程起始地址的一个相对地址</h4><h4id="当前进程的起始单元地址称为基址加上逻辑地址就可以得到在内存中的物理地址">当前进程的起始单元地址，称为基址，加上逻辑地址，就可以得到在内存中的物理地址</h4><h4id="逻辑地址-程序开始的相对位置"><font color="#0099ff">逻辑地址-程序开始的相对位置</font></h4><h3 id="分页"><font color=Red>分页:</font></h3><ul><li>将内存分为固定大小的小存储块，这个小存储块我们称为“帧”或“页帧”</li><li>进程也按照同样的大小划分为若干个固定块，称为“页”。操作系统负责维护空闲帧的列表</li><li><font color=skyBlue>在给进程分配内存的时候，按照帧来进行分配若干个帧给进程。进程占用的帧_不一定需要是连续的帧_</font></li><li>进程中的页不需要全部全部加载到内存中，可以在需要的时候进行换入产生了虚拟地址的概念</li></ul><h3 id="分段">分段:</h3><h4id="分页技术中页对程序员来说是不可见的由操作系统来完成通过分页技术给程序员提供了比实际内存更大的地址空间">分页技术中，页对程序员来说是不可见的，由操作系统来完成，通过分页技术，给程序员提供了比实际内存更大的地址空间</h4><h4id="分段技术对程序员来说是可见的程序员或操作系统可以给程序或数据分配不同的段一个程序可以包含多个程序段或数据段">分段技术对程序员来说是可见的。程序员或操作系统可以给程序或数据分配不同的段，一个程序可以包含多个程序段或数据段</h4><h4id="好处是简化管理要求允许程序对不同段进行独立修改和编译并且多个进程可以共享段可以实现段保护">好处是：简化管理要求，允许程序对不同段进行独立修改和编译，并且多个进程可以共享段，可以实现段保护</h4><h4id="一般采用分段和分页相结合的方式段表决定段的开始地址">一般采用分段和分页相结合的方式。段表决定段的开始地址</h4><h2 id="重点知识点-7"><font color=Red>重点知识点:</font></h2><h3 id="页表"><font color=“#0099ff>页表</font></h3><h4 id="每个进程有它自己的页表">每个进程有它自己的页表</h4><h4id="每个页表包含页在内存中对应的帧号">每个页表包含页在内存中对应的帧号</h4><ul><li>Vitural Address</li></ul><table><thead><tr class="header"><th>Page Number</th><th>Offset</th></tr></thead><tbody></tbody></table><ul><li>Page Table Entry</li></ul><table><thead><tr class="header"><th>P</th><th>M</th><th>Other Control Bits</th><th>Frame Number</th></tr></thead><tbody></tbody></table><ul><li>寻址的虚拟地址为“页号+偏移量”</li><li>页表中指明了这个页对应的内存的帧序号</li><li>通过“页——》帧”的转换，以及页内的偏移量，就可以得到逻辑地址在内存中的实际地址### 分页的地址翻译: <img src="/image/res/52.png" /></li></ul><h3 id="逻辑地址和物理地址">逻辑地址和物理地址:</h3><p><img src="/image/res/53.png" /> &gt; relative address within page:页内相对地址 <br> &gt; Logical Address: 逻辑地址 <br> &gt; PhysicalAddress: 物理地址 <br></p><h3 id="虚拟存储器">虚拟存储器:</h3><h4id="操作系统能够管理页或者段在辅存和主存之间的移动以进行换出和换入通过交换的方式"><font color=Red>(*)</font>操作系统能够管理页或者段在辅存和主存之间的移动，以进行换出和换入<font color=Red>(通过交换的方式)</font></h4><h4 id="请求分页页加载方式">请求分页(页加载方式)：</h4><blockquote><p>一个进程的所有页不需要都加载到存储器中 <br> 需要的页才会载入内存中<br></p></blockquote><h4 id="页失效的处理">页失效的处理:</h4><blockquote><ul><li>需要的页不在内存中的时候，就会产生一个“页失效”，page fault <br></li><li><font color=Red>(*)</font>操作系统将需要的页载入到内存中，同时需要将某页替换出去，以给载入的页提供空间，这称之为“页替换”<br></li><li>将哪个页替换出去，是需要考虑的一个问题。通常是采用最近最少使用原则<br></li></ul></blockquote><h4 id="优点">优点：</h4><ul><li>不需要将所有需要运行的进程放到内存中</li><li>根据需要交换页</li><li>运行的进程大于实际可用的内存</li><li>主存称为实际内存</li><li>用户程序能够看到更多的内存-虚拟内存</li></ul><h2 id="补充-4"><font color=Red>补充:</font></h2><h3 id="页表的操作">页表的操作：</h3><p><img src="/image/res/54.png" /></p><h3 id="段表">段表：</h3><ul><li>Virtual Address</li></ul><table><thead><tr class="header"><th>Segment Number</th><th>Offset</th></tr></thead><tbody></tbody></table><ul><li>Segment Table Entry</li></ul><table><thead><tr class="header"><th>P</th><th>M</th><th>Other Control Bit</th><th>Length</th><th>Segment Base</th></tr></thead><tbody></tbody></table><blockquote><p>P = present bit <br> M = modified bit <br> *段需要有段表来实现地址转换 *虚拟地址中包含段号，从段表中找到改段号对应的段基址，就可以根据偏移量到内存中得到这个虚拟地址对应的物理地址</p></blockquote><h2 id="补充-5"><font color=Red>补充:</font></h2><h3 id="求物理地址例题"><font color=Red>(**)</font>求物理地址例题：</h3><ul><li>假设当前在处理器上执行的进程的页面表如下所示。所有的数字都是十进制的，所有的数字都从零开始编号，所有的地址都是内存字节地址。页面大小为1024个字节<img src="/image/res/55.png" /></li><li>如果有什么物理地址，下列每个虚拟地址将对应什么物理地址？（如果有任何页面错误，请不要尝试处理。）<div class="note note-info">            <ul><li>1052: &gt; 1052 = 1024 + 28，虚拟页号为1，页内偏移为28 &gt;映射到物理页帧为7。所以物理地址为7 × 1024+28 = 7196</li><li>2221: &gt; 2221 = 2 × 1024 + 173，虚拟页号为2，页内偏移为173 &gt;虚拟页号为2的页，不在内存中。页缺失</li><li>5499: &gt; 5499 = 5 × 1024 + 379，虚拟页号为5，页内偏移为379 &gt;映射到物理页帧为7。所以物理地址为0 × 1024+379 = 379</li><li><font color=Blue>总结： <br>首先将题目所给的要转换的数(例如：1052)转换成n * 1024 + m 的形式 <br>n为虚拟页号，m为页内偏移量 <br>通过题目所给表格找出对应虚拟页号所映射到的物理页帧号_a_(若不存在，则页缺失)<br> 物理地址为：a * 1024 + m</font> <br></li></ul>          </div></li></ul><h4 id="提示">提示：</h4><h5id="为往年题中选择判断题的考点"><font color=Red>(*)</font>为往年题中选择判断题的考点</h5><h5id="为往年题中大题的考点"><font color=Red>(**)</font>为往年题中大题的考点</h5>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
